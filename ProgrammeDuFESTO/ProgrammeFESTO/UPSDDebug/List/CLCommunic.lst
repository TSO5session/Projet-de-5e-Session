###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.1.40194/W32 for 8051         08/Sep/2014  18:14:28 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  near                                               #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Synchro\Dropbox\Travaux\Automne                 #
#                          2014\Prog\Labo1\Programme\CLCommunic.cpp           #
#    Command line       =  "C:\Synchro\Dropbox\Travaux\Automne                #
#                          2014\Prog\Labo1\Programme\CLCommunic.cpp" -D       #
#                          UPSD3254A --preprocess=cl                          #
#                          "C:\Synchro\Dropbox\Travaux\Automne                #
#                          2014\Prog\Labo1\Programme\UPSDDebug\List\" -lC     #
#                          "C:\Synchro\Dropbox\Travaux\Automne                #
#                          2014\Prog\Labo1\Programme\UPSDDebug\List\" -lA     #
#                          "C:\Synchro\Dropbox\Travaux\Automne                #
#                          2014\Prog\Labo1\Programme\UPSDDebug\List\" -o      #
#                          "C:\Synchro\Dropbox\Travaux\Automne                #
#                          2014\Prog\Labo1\Programme\UPSDDebug\Obj\" -e       #
#                          --no_cse --no_unroll --no_inline --no_code_motion  #
#                          --no_tbaa --debug --core=plain --dptr=16,1         #
#                          --data_model=large --code_model=near               #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data --nr_virtual_regs 8         #
#                          --dlib_config "C:\Program Files (x86)\IAR          #
#                          Systems\Embedded Workbench                         #
#                          6.0\8051\LIB\DLIB\dl8051Normal.h" -Ol --eec++      #
#    List file          =  C:\Synchro\Dropbox\Travaux\Automne                 #
#                          2014\Prog\Labo1\Programme\UPSDDebug\List\CLCommuni #
#                          c.lst                                              #
#    Object file        =  C:\Synchro\Dropbox\Travaux\Automne                 #
#                          2014\Prog\Labo1\Programme\UPSDDebug\Obj\CLCommunic #
#                          .r51                                               #
#                                                                             #
#                                                                             #
###############################################################################

C:\Synchro\Dropbox\Travaux\Automne 2014\Prog\Labo1\Programme\CLCommunic.cpp
      1          //**********************  Fichier: CLCommunic.cpp
      2          //  Description : Fonctions necessaire pour communiquer avec le port serie:
      3          //
      4          // 
      5          //CLCommunic()                                          Constructeur par defaut
      6          //CLCommunic(UC ucLongBuf, UC ucLongTrame, UI uiBaud)  Construct initialisateur
      7          //~CLCommunic()                                                     Destructeur 
      8          //UC ucInitLongTrame(UC ucLong)                 Pour initialiser longueur trame
      9          //UC static ucLireNbCaractRecu()         Fct pour lire nombre de caractere recu
     10          //UC ucLireEtatTrame()                         Fct pour lire l'etat de la trame
     11          //char *ucpLireTrame()                Fct qui retourne adresse du debut lecture
     12          //vTransCaratere(UC ucCar)                    Fct pour transmettre un caractere
     13          //vTransChiffre(UI uiChiffreAAfficher)          Fct pour transmettre un chiffre 
     14          //vAffChaine(char const *ucpMessage)   Fct pour transmettre chaine de caractere
     15          //void vInitBaudRate(UI uiBaud)        Fct pour intialiser le baudrate et timer
     16          //__interrupt static void vInteruptSerial();     Fct pour recevoir un caractere
     17          //UC ucValideTrame()                                 Fct pour valider une trame
     18          //
     19          //  Composition: aucune
     20          //  Heritage : aucun
     21          //
     22          //  Programmeur: Philippe Dubois
     23          //  Cours: 247-436
     24          //                                                                           
     25          //  Date: 10 avril 2014
     26          //                                                                           //
     27          //  Compilateur: IAR 8.1                                  
     28          //                                                                           //
     29          //  Modification:                                                            //
     30          //                                                                           //
     31          ///////////////////////////////////////////////////////////////////////////////
     32          #include "CLCommunic.h"             //inclue CLCommunic.h.

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IE
   \                     _A_IE:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x99
   \   unsigned char volatile __sfr SBUF
   \                     SBUF:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x98
   \   union <unnamed> volatile __sfr _A_SCON
   \                     _A_SCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x87
   \   union <unnamed> volatile __sfr _A_PCON
   \                     _A_PCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x88
   \   union <unnamed> volatile __sfr _A_TCON
   \                     _A_TCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8d
   \   unsigned char volatile __sfr TH1
   \                     TH1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x89
   \   union <unnamed> volatile __sfr _A_TMOD
   \                     _A_TMOD:
   \   000000                DS 1
     33          #include "ConversionKeilToIAR.h"
     34          
     35           ///// Initialise les variables statiques.

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     36          UC    CLCommunic :: ucEtatTrame       = INCOMPLET;      // Trame incomplete.
   \                     ??ucEtatTrame:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     37          UC    CLCommunic :: ucNbCaractRecu    = 0;              // Nombre de caractere recu = 0
   \                     ??ucNbCaractRecu:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_I, align 1, keep-with-next
     38          UC    CLCommunic :: ucLongueurTrame   = LONGUEURTRAME;  // Initialise les longueur du 
   \                     ??ucLongueurTrame:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for ucLongueurTrame>`
   \   000001                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
     39          UC    CLCommunic :: ucLongueurTampon  = LONGUEURTAMPON; // buffer et trame.
   \                     ??ucLongueurTampon:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for ucLongueurTampon>`
   \   000001                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     40          UC    CLCommunic :: ucCaractereRecu   = NULL;
   \                     ??ucCaractereRecu:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     41          UC    CLCommunic :: ucEtatReception   = INACTIF;
   \                     ??ucEtatReception:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     42          char *CLCommunic :: cpDebutTrame      = NULL;           // Initialise lse pointeur a NULL.
   \                     ??cpDebutTrame:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     43          char *CLCommunic :: cpFinTrame        = NULL;
   \                     ??cpFinTrame:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     44          char *CLCommunic :: cptrEcriture      = NULL;
   \                     ??cptrEcriture:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     45          char *CLCommunic :: cptrLecture       = NULL;
   \                     ??cptrLecture:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     46          char *CLCommunic :: cTabCaractereRecu = NULL;
   \                     ??cTabCaractereRecu:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
     47          
     48          
     49          //*****************************************************************************
     50          // Nom de la fct:   CLCommunic(void)
     51          // Description:     Constructeur qui permet d'initialiser par defaut le port  
     52          //                  serie du micro controleur a  9600 bdr, un tampon de 12
     53          //                  et une trame a 4 characteres. Initialise les differents
     54          //                  pointeurs au debut et la la fin du tampon.
     55          //
     56          // INCLUDE:         #include "_TypeCible.h", "CLCommunic.h" 
     57          // Prototype:       CLCommunic(void);
     58          //
     59          //
     60          // Parametre d'entree: Aucune
     61          //                     
     62          // Parametre de sortie: Aucune
     63          //
     64          // Procedure appelees: vInitBaudRate(), 
     65          //                     
     66          // Exemple d'appel: class CLCommunic clCommunic();
     67          //
     68          // Fait par: Philippe Dubois
     69          // Date:            10 avril 2014       
     70          // Revision :       A      
     71          // Modification : 
     72          //***************************************************************************** 

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
     73          CLCommunic::CLCommunic(void)
   \                     ??CLCommunic:
     74          {
   \   000000   74F8         MOV     A,#-0x8
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 8
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
     75           cTabCaractereRecu = new char[LONGUEURTAMPON]; // Definit tableau de longueur
   \   000009                ; Setup parameters for call to function operator new[](unsigned int)
   \   000009   7A0C         MOV     R2,#0xc
   \   00000B   7B00         MOV     R3,#0x0
   \   00000D   12....       LCALL   `??operator new[]`
   \   000010   90....       MOV     DPTR,#??cTabCaractereRecu
   \   000013   EA           MOV     A,R2
   \   000014   F0           MOVX    @DPTR,A
   \   000015   A3           INC     DPTR
   \   000016   EB           MOV     A,R3
   \   000017   F0           MOVX    @DPTR,A
     76                                                         // LONGUEURTAMPON.
     77           ucLongueurTrame  = LONGUEURTRAME;             // Definit longueur de la trame.
   \   000018   90....       MOV     DPTR,#??ucLongueurTrame
   \   00001B   7404         MOV     A,#0x4
   \   00001D   F0           MOVX    @DPTR,A
     78           ucLongueurTampon = LONGUEURTAMPON;            // Definit longueur tampon.
   \   00001E   90....       MOV     DPTR,#??ucLongueurTampon
   \   000021   740C         MOV     A,#0xc
   \   000023   F0           MOVX    @DPTR,A
     79           
     80           cpDebutTrame = &cTabCaractereRecu[0];                  // Pointeur sur debut tampon.
   \   000024   90....       MOV     DPTR,#??cTabCaractereRecu
   \   000027   E0           MOVX    A,@DPTR
   \   000028   F8           MOV     R0,A
   \   000029   A3           INC     DPTR
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F9           MOV     R1,A
   \   00002C   90....       MOV     DPTR,#??cpDebutTrame
   \   00002F   E8           MOV     A,R0
   \   000030   F0           MOVX    @DPTR,A
   \   000031   A3           INC     DPTR
   \   000032   E9           MOV     A,R1
   \   000033   F0           MOVX    @DPTR,A
     81           cpFinTrame   = &cTabCaractereRecu[(LONGUEURTAMPON-1)]; // Pointeur sur fin tampon
   \   000034   90....       MOV     DPTR,#??cTabCaractereRecu
   \   000037   E0           MOVX    A,@DPTR
   \   000038   240B         ADD     A,#0xb
   \   00003A   F8           MOV     R0,A
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   3400         ADDC    A,#0x0
   \   00003F   F9           MOV     R1,A
   \   000040   90....       MOV     DPTR,#??cpFinTrame
   \   000043   E8           MOV     A,R0
   \   000044   F0           MOVX    @DPTR,A
   \   000045   A3           INC     DPTR
   \   000046   E9           MOV     A,R1
   \   000047   F0           MOVX    @DPTR,A
     82           cptrEcriture = &cTabCaractereRecu[0];                  // Pointeur ecriture au debut.
   \   000048   90....       MOV     DPTR,#??cTabCaractereRecu
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   F8           MOV     R0,A
   \   00004D   A3           INC     DPTR
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   F9           MOV     R1,A
   \   000050   90....       MOV     DPTR,#??cptrEcriture
   \   000053   E8           MOV     A,R0
   \   000054   F0           MOVX    @DPTR,A
   \   000055   A3           INC     DPTR
   \   000056   E9           MOV     A,R1
   \   000057   F0           MOVX    @DPTR,A
     83           cptrLecture  = &cTabCaractereRecu[0];                  // Pointeur lecture au debut.
   \   000058   90....       MOV     DPTR,#??cTabCaractereRecu
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   F8           MOV     R0,A
   \   00005D   A3           INC     DPTR
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   F9           MOV     R1,A
   \   000060   90....       MOV     DPTR,#??cptrLecture
   \   000063   E8           MOV     A,R0
   \   000064   F0           MOVX    @DPTR,A
   \   000065   A3           INC     DPTR
   \   000066   E9           MOV     A,R1
   \   000067   F0           MOVX    @DPTR,A
     84           
     85           vInitBaudRate(9600);                                   // Initialise le port serie.
   \   000068                ; Setup parameters for call to function CLCommunic::vInitBaudRate(UI)
   \   000068   7C80         MOV     R4,#-0x80
   \   00006A   7D25         MOV     R5,#0x25
   \   00006C   EE           MOV     A,R6
   \   00006D   FA           MOV     R2,A
   \   00006E   EF           MOV     A,R7
   \   00006F   FB           MOV     R3,A
   \   000070   12....       LCALL   ??vInitBaudRate
     86          }
   \   000073   EE           MOV     A,R6
   \   000074   FA           MOV     R2,A
   \   000075   EF           MOV     A,R7
   \   000076   FB           MOV     R3,A
   \   000077   7F01         MOV     R7,#0x1
   \   000079   02....       LJMP    ?FUNC_LEAVE_XDATA
     87          
     88          
     89          //*****************************************************************************
     90          // Nom de la fct:   CLCommunic
     91          // Description:     Constructeur qui permet d'initialiser  le port  
     92          //                  serie du micro controleur a  la vitesse voulue, un tampon 
     93          //                  de taille dynamique et la longueur de la trame.
     94          //                  Initialise les differents pointeurs au debut et la la fin 
     95          //                  du tampon.
     96          //
     97          // INCLUDE:         #include "_TypeCible.h", "CLCommunic.h" 
     98          // Prototype:     CLCommunic(UC ucLongBuf, UC ucLongTrame, UI uiBaud);  
     99          //
    100          //
    101          // Parametre d'entree: ucLongBuf pour longueur du trableau
    102          //                     ucLongTrame pour longueur trame
    103          //                     uiBaud pour la vitesse du port serie
    104          //
    105          // Parametre de sortie: Aucune
    106          //
    107          // Procedure appelees: vInitBaudRate(), ucInitLongTrame()
    108          //                     
    109          // Exemple d'appel: class CLCommunic clCommunic();
    110          //
    111          // Fait par: Philippe Dubois
    112          // Date:            10 avril 2014       
    113          // Revision :       A      
    114          // Modification : 
    115          //*****************************************************************************

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    116          CLCommunic :: CLCommunic(UC ucLongBuf, UC ucLongTrame, UI uiBaud)
   \                     ??CLCommunic_1:
    117          {
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   89..         MOV     ?V0 + 2,R1
   \   00000B   8C..         MOV     ?V0 + 3,R4
   \   00000D   740D         MOV     A,#0xd
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   E0           MOVX    A,@DPTR
   \   000013   FE           MOV     R6,A
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   FF           MOV     R7,A
    118           cTabCaractereRecu = new char[ucLongBuf]; // Initialise un tableau de longueur
   \   000017                ; Setup parameters for call to function operator new[](unsigned int)
   \   000017   85....       MOV     ?V0 + 4,?V0 + 2
   \   00001A   75..00       MOV     ?V0 + 5,#0x0
   \   00001D   AA..         MOV     R2,?V0 + 4
   \   00001F   AB..         MOV     R3,?V0 + 5
   \   000021   12....       LCALL   `??operator new[]`
   \   000024   90....       MOV     DPTR,#??cTabCaractereRecu
   \   000027   EA           MOV     A,R2
   \   000028   F0           MOVX    @DPTR,A
   \   000029   A3           INC     DPTR
   \   00002A   EB           MOV     A,R3
   \   00002B   F0           MOVX    @DPTR,A
    119                                                    // voulue.
    120           ucLongueurTampon = ucLongBuf;            // Longueur tampon = ucLongBuf.
   \   00002C   E5..         MOV     A,?V0 + 2
   \   00002E   90....       MOV     DPTR,#??ucLongueurTampon
   \   000031   F0           MOVX    @DPTR,A
    121           ucInitLongTrame(ucLongTrame);            // Verifie si longueur trame 
   \   000032                ; Setup parameters for call to function CLCommunic::ucInitLongTrame(UC)
   \   000032   A9..         MOV     R1,?V0 + 3
   \   000034   AA..         MOV     R2,?V0 + 0
   \   000036   AB..         MOV     R3,?V0 + 1
   \   000038   12....       LCALL   ??ucInitLongTrame
   \   00003B   E9           MOV     A,R1
    122                                                    // < longueur tampon. 
    123           cpDebutTrame = &cTabCaractereRecu[0];    // Pointeur pour debut tampon.
   \   00003C   90....       MOV     DPTR,#??cTabCaractereRecu
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   F8           MOV     R0,A
   \   000041   A3           INC     DPTR
   \   000042   E0           MOVX    A,@DPTR
   \   000043   F9           MOV     R1,A
   \   000044   90....       MOV     DPTR,#??cpDebutTrame
   \   000047   E8           MOV     A,R0
   \   000048   F0           MOVX    @DPTR,A
   \   000049   A3           INC     DPTR
   \   00004A   E9           MOV     A,R1
   \   00004B   F0           MOVX    @DPTR,A
    124           cpFinTrame   = &cTabCaractereRecu[(ucLongBuf-1)];// Pointeur pour fin tampon.
   \   00004C   E5..         MOV     A,?V0 + 2
   \   00004E   A8..         MOV     R0,?V0 + 2
   \   000050   7900         MOV     R1,#0x0
   \   000052   90....       MOV     DPTR,#??cTabCaractereRecu
   \   000055   E0           MOVX    A,@DPTR
   \   000056   28           ADD     A,R0
   \   000057   F8           MOV     R0,A
   \   000058   A3           INC     DPTR
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   39           ADDC    A,R1
   \   00005B   F9           MOV     R1,A
   \   00005C   E8           MOV     A,R0
   \   00005D   24FF         ADD     A,#-0x1
   \   00005F   F8           MOV     R0,A
   \   000060   E9           MOV     A,R1
   \   000061   34FF         ADDC    A,#-0x1
   \   000063   F9           MOV     R1,A
   \   000064   90....       MOV     DPTR,#??cpFinTrame
   \   000067   E8           MOV     A,R0
   \   000068   F0           MOVX    @DPTR,A
   \   000069   A3           INC     DPTR
   \   00006A   E9           MOV     A,R1
   \   00006B   F0           MOVX    @DPTR,A
    125           cptrEcriture = &cTabCaractereRecu[0];    // Pointeur ecriture et lecture au 
   \   00006C   90....       MOV     DPTR,#??cTabCaractereRecu
   \   00006F   E0           MOVX    A,@DPTR
   \   000070   F8           MOV     R0,A
   \   000071   A3           INC     DPTR
   \   000072   E0           MOVX    A,@DPTR
   \   000073   F9           MOV     R1,A
   \   000074   90....       MOV     DPTR,#??cptrEcriture
   \   000077   E8           MOV     A,R0
   \   000078   F0           MOVX    @DPTR,A
   \   000079   A3           INC     DPTR
   \   00007A   E9           MOV     A,R1
   \   00007B   F0           MOVX    @DPTR,A
    126           cptrLecture  = &cTabCaractereRecu[0];    // debut du tampon.
   \   00007C   90....       MOV     DPTR,#??cTabCaractereRecu
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   F8           MOV     R0,A
   \   000081   A3           INC     DPTR
   \   000082   E0           MOVX    A,@DPTR
   \   000083   F9           MOV     R1,A
   \   000084   90....       MOV     DPTR,#??cptrLecture
   \   000087   E8           MOV     A,R0
   \   000088   F0           MOVX    @DPTR,A
   \   000089   A3           INC     DPTR
   \   00008A   E9           MOV     A,R1
   \   00008B   F0           MOVX    @DPTR,A
    127           vInitBaudRate(uiBaud);                   // Initialise la vitesse de 
   \   00008C                ; Setup parameters for call to function CLCommunic::vInitBaudRate(UI)
   \   00008C   EE           MOV     A,R6
   \   00008D   FC           MOV     R4,A
   \   00008E   EF           MOV     A,R7
   \   00008F   FD           MOV     R5,A
   \   000090   AA..         MOV     R2,?V0 + 0
   \   000092   AB..         MOV     R3,?V0 + 1
   \   000094   12....       LCALL   ??vInitBaudRate
    128                                                    // communication.
    129          }
   \   000097   AA..         MOV     R2,?V0 + 0
   \   000099   AB..         MOV     R3,?V0 + 1
   \   00009B   7F06         MOV     R7,#0x6
   \   00009D   02....       LJMP    ?FUNC_LEAVE_XDATA
    130          
    131          //*****************************************************************************
    132          // Nom de la fct:   ~CLCommunic
    133          // Description:     Desctructeur qui libert la memoire pris par le tampon. 
    134          //
    135          // INCLUDE:        #include "_TypeCible.h", "CLCommunic.h" 
    136          // Prototype:      ~CLCommunic(void); 
    137          //
    138          //
    139          // Parametre d'entree: aucun
    140          //
    141          // Parametre de sortie: Aucun
    142          //
    143          // Procedure appelees: aucun
    144          //                     
    145          // Exemple d'appel:  
    146          //
    147          // Fait par: Philippe Dubois
    148          // Date:            10 avril 2014       
    149          // Revision :       A      
    150          // Modification : 
    151          //*****************************************************************************

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    152          CLCommunic :: ~CLCommunic(void)
   \                     `?~CLCommunic`:
    153          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    154          if(cTabCaractereRecu)            // Verification pour s'assurer que le 
   \   000004   90....       MOV     DPTR,#??cTabCaractereRecu
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F8           MOV     R0,A
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F9           MOV     R1,A
   \   00000C   E8           MOV     A,R0
   \   00000D   49           ORL     A,R1
   \   00000E   6015         JZ      `?~CLCommunic_1`
    155            {                                // pointeur n'a pas deja ete libere
    156             delete cTabCaractereRecu;       // Libert la memoire prise par le tampon.
   \   000010                ; Setup parameters for call to function operator delete(void *)
   \   000010   90....       MOV     DPTR,#??cTabCaractereRecu
   \   000013   E0           MOVX    A,@DPTR
   \   000014   FA           MOV     R2,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   FB           MOV     R3,A
   \   000018   12....       LCALL   `??operator delete`
    157             cTabCaractereRecu = NULL;       // Pour mettre a 0 le pointeur.
   \   00001B   90....       MOV     DPTR,#??cTabCaractereRecu
   \   00001E   7400         MOV     A,#0x0
   \   000020   F0           MOVX    @DPTR,A
   \   000021   A3           INC     DPTR
   \   000022   7400         MOV     A,#0x0
   \   000024   F0           MOVX    @DPTR,A
    158            }
    159          }
   \                     `?~CLCommunic_1`:
   \   000025   D083         POP     DPH
   \   000027   D082         POP     DPL
   \   000029   22           RET
    160          
    161          //*****************************************************************************
    162          // Nom de la fct:   ucInitLongTrame
    163          // Description:     Verifie si la trame entree est inferieure au tampon
    164          //                  sinon la longueur de la trame = a celle du buffer.
    165          //
    166          // INCLUDE:        #include "_TypeCible.h", "CLCommunic.h" 
    167          // Prototype:      UC ucInitLongTrame(UC ucLong);
    168          //
    169          //
    170          // Parametre d'entree: ucLong longueur voulue
    171          //
    172          // Parametre de sortie: ucValide pour valide ou non la taille
    173          //
    174          // Procedure appelees: aucun
    175          //                     
    176          // Exemple d'appel:  ucInitLongTrame(ucLongTrame);
    177          //
    178          // Fait par: Philippe Dubois
    179          // Date:            10 avril 2014       
    180          // Revision :       A      
    181          // Modification : 
    182          //*****************************************************************************
    183          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    184          UC CLCommunic :: ucInitLongTrame(UC ucLong)
   \                     ??ucInitLongTrame:
    185          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   F8           MOV     R0,A
    186          UC ucValide;                           // Varaible pour valider ou non.
    187          
    188          if(ucLong <= ucLongueurTampon)         // Si longueur trame voulue <= a la longueur
   \   000006   90....       MOV     DPTR,#??ucLongueurTampon
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   C3           CLR     C
   \   00000B   98           SUBB    A,R0
   \   00000C   4007         JC      ??ucInitLongTrame_1
    189            {                                    // du tampon.
    190             ucLongueurTrame = ucLong;           // longueur trame = longueur trame voulue.
   \   00000E   E8           MOV     A,R0
   \   00000F   90....       MOV     DPTR,#??ucLongueurTrame
   \   000012   F0           MOVX    @DPTR,A
    191             ucValide = VRAI;                    // ucValide = Vrai.
   \   000013   7901         MOV     R1,#0x1
    192            }
    193          
    194          if(ucLong > ucLongueurTampon)          // Si longueur trame voulue > a la longueur
   \                     ??ucInitLongTrame_1:
   \   000015   90....       MOV     DPTR,#??ucLongueurTampon
   \   000018   E0           MOVX    A,@DPTR
   \   000019   C3           CLR     C
   \   00001A   98           SUBB    A,R0
   \   00001B   500A         JNC     ??ucInitLongTrame_2
    195            {                                    // du tampon.
    196             ucLongueurTrame = ucLongueurTampon; // longueur trame = longueur tampon.
   \   00001D   90....       MOV     DPTR,#??ucLongueurTampon
   \   000020   E0           MOVX    A,@DPTR
   \   000021   90....       MOV     DPTR,#??ucLongueurTrame
   \   000024   F0           MOVX    @DPTR,A
    197             ucValide = FAUX;                    // ucValide = Faux.
   \   000025   7900         MOV     R1,#0x0
    198            } 
    199          
    200          return(ucValide);                      // Retourne etat de ucValide.
   \                     ??ucInitLongTrame_2:
   \   000027   D083         POP     DPH
   \   000029   D082         POP     DPL
   \   00002B   22           RET
    201          }
    202          
    203          
    204          //*****************************************************************************
    205          // Nom de la fct:   ucValideTrame
    206          // Description:     Valide la trame recue, additionne tous les caracteres 
    207          //                  recues et commpare avec le checksum.
    208          //
    209          // INCLUDE:        #include "_TypeCible.h", "CLCommunic.h" 
    210          // Prototype:      UC ucValideTrame(void);
    211          //
    212          //
    213          // Parametre d'entre: aucun
    214          //
    215          // Parametre de sortie: ucValide pour valide ou non la trame.
    216          //
    217          // Procedure appelees: aucun
    218          //                     
    219          // Exemple d'appel: if(ucValideTrame() == VRAI)
    220          //
    221          // Fait par: Philippe Dubois
    222          // Date:            10 avril 2014       
    223          // Revision :       A      
    224          // Modification : 
    225          //*****************************************************************************

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    226          UC CLCommunic :: ucValideTrame(void)
   \                     ??ucValideTrame:
    227          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    228          UC ucValide;               // Variable pour etat valide ou non.      
    229          UC ucSomme;                // variable pour la somme des caracteres recus.
    230          ucSomme = 0;               // Initialise la somme a 0.
   \   000004   7A00         MOV     R2,#0x0
    231          UC ucBoucle;               // Varialbe pour boucle.
    232           
    233          char *cPtrVerification;    // pointeur sur la tramme recu
    234          cPtrVerification = cptrLecture; // Intialise l'adresse du debut de la trame.
   \   000006   90....       MOV     DPTR,#??cptrLecture
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F8           MOV     R0,A
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F9           MOV     R1,A
    235            
    236          ucBoucle = (ucLongueurTrame - 1);         // Pour additionner toutes les valeurs
   \   00000E   90....       MOV     DPTR,#??ucLongueurTrame
   \   000011   E0           MOVX    A,@DPTR
   \   000012   24FF         ADD     A,#-0x1
   \   000014   FB           MOV     R3,A
   \   000015   8011         SJMP    ??ucValideTrame_1
    237                                                    // sauf le dernier
    238          for(;ucBoucle > 0; ucBoucle--)
    239            {
    240             ucSomme = *cPtrVerification + ucSomme; // Additionne le caractere avec somme.
   \                     ??ucValideTrame_2:
   \   000017   8882         MOV     DPL,R0
   \   000019   8983         MOV     DPH,R1
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   2A           ADD     A,R2
   \   00001D   FA           MOV     R2,A
    241             cPtrVerification ++;                   // Valeur suivante.        
   \   00001E   8882         MOV     DPL,R0
   \   000020   8983         MOV     DPH,R1
   \   000022   A3           INC     DPTR
   \   000023   A882         MOV     R0,DPL
   \   000025   A983         MOV     R1,DPH
    242            }
   \   000027   1B           DEC     R3
   \                     ??ucValideTrame_1:
   \   000028   EB           MOV     A,R3
   \   000029   C3           CLR     C
   \   00002A   9401         SUBB    A,#0x1
   \   00002C   50E9         JNC     ??ucValideTrame_2
    243                                                    // Compare la somme avec le checksum recu.
    244          if(ucSomme == *cPtrVerification)          // Si egal?
   \   00002E   8882         MOV     DPL,R0
   \   000030   8983         MOV     DPH,R1
   \   000032   E0           MOVX    A,@DPTR
   \   000033   6A           XRL     A,R2
   \   000034   7004         JNZ     ??ucValideTrame_3
    245            {
    246             ucValide = VRAI;                       // Trame correcte.
   \   000036   7901         MOV     R1,#0x1
   \   000038   8002         SJMP    ??ucValideTrame_4
    247            }
    248          else                                      // Sinon 
    249            {
    250             ucValide = FAUX;                       // Trame incorrecte.
   \                     ??ucValideTrame_3:
   \   00003A   7900         MOV     R1,#0x0
    251            }
    252          
    253          return(ucValide);                         // Retourne valide ou non.
   \                     ??ucValideTrame_4:
   \   00003C   D083         POP     DPH
   \   00003E   D082         POP     DPL
   \   000040   22           RET
    254          } 
    255          
    256          //*****************************************************************************
    257          // Nom de la fct:   vTransCaratere                  Fait par: Philippe Dubois
    258          // Date:            2 octobre 2013             
    259          // Revision :       A      
    260          // Modification : 
    261          // INCLUDE:         #include "_TypeCible.h", "CLCommunic.h" 
    262          // Prototype:       void vTransCaratere(UC ucCar);
    263          //
    264          // Description:     Fonction qui permet de transmettre un caractere par le port 
    265          //                  serie, et on attend que le caractere soit completement 
    266          //                  envoye par "polling" avec le flag TI_0.
    267          //
    268          // Parametre d'entree: ucCar: caractere qu'on veut envoyer. 
    269          //                     
    270          //
    271          // Parametre de sortie: aucune
    272          //
    273          // Procedure appelees: aucune.
    274          //                     
    275          // Exemple d'appel: clCommunic.vTransCaratere('A') 
    276          //*****************************************************************************

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    277          void CLCommunic :: vTransCaratere(UC ucCar)
   \                     ??vTransCaratere:
    278          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    279          SBUF0 = ucCar;             // Envoye le caractere dans SBUF0 pour le transmetre sur TX                     
   \   000000   8999         MOV     0x99,R1
    280          while(TI_0 ==0);           // Si le flag TI_0 se met a 1 (termine)
   \                     ??vTransCaratere_1:
   \   000002   A299         MOV     C,0x98.1
   \   000004   50FC         JNC     ??vTransCaratere_1
    281          TI_0  = 0;                 // Remet le flag a 0.
   \   000006   C299         CLR     0x98.1
    282          }
   \   000008   22           RET
   \   000009                REQUIRE SBUF
   \   000009                REQUIRE _A_SCON
    283          
    284          
    285          
    286          //*****************************************************************************
    287          // Nom de la fct:   vAffChaine
    288          // Description:     Transmet une chaine de caracteres sur le port serie.
    289          //
    290          // INCLUDE:        #include "_TypeCible.h", "CLCommunic.h" 
    291          // Prototype:      void vAffChaine(char const *ucpMessage)
    292          //
    293          //
    294          // Parametre d'entre: *ucpMessage pour chaine de caractere.
    295          //
    296          // Parametre de sortie: aucun
    297          //
    298          // Procedure appelees: vTransCaratere()
    299          //                     
    300          // Exemple d'appel: clCommunic.vAffChaine("TEST");
    301          //
    302          // Fait par: Philippe Dubois
    303          // Date:            10 avril 2014       
    304          // Revision :       A      
    305          // Modification : 
    306          //*****************************************************************************

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    307          void CLCommunic :: vAffChaine(char const *ucpMessage)
   \                     ??vAffChaine:
    308          {
   \   000000   74F8         MOV     A,#-0x8
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 8
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C82         MOV     DPL,R4
   \   00000B   8D83         MOV     DPH,R5
   \   00000D   800A         SJMP    ??vAffChaine_1
    309          while(*ucpMessage != 0x00)          // Tant qu'on a pas atteint la fin de 
    310            {                                 // la chaine.
    311             vTransCaratere(*ucpMessage);     // Transmet le caractere.
   \                     ??vAffChaine_2:
   \   00000F                ; Setup parameters for call to function CLCommunic::vTransCaratere(UC)
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F9           MOV     R1,A
   \   000011   EE           MOV     A,R6
   \   000012   FA           MOV     R2,A
   \   000013   EF           MOV     A,R7
   \   000014   FB           MOV     R3,A
   \   000015   12....       LCALL   ??vTransCaratere
    312             ucpMessage++;                    // Passe au caractere suivant.
   \   000018   A3           INC     DPTR
    313            }
   \                     ??vAffChaine_1:
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   70F3         JNZ     ??vAffChaine_2
    314          }
   \   00001C   7F01         MOV     R7,#0x1
   \   00001E   02....       LJMP    ?FUNC_LEAVE_XDATA
    315          
    316          //*****************************************************************************
    317          // Nom de la fct:   ucLireNbCaractRecu                Fait par: Philippe Dubois
    318          // Date:            2 octobre 2013             
    319          // Revision :       A      
    320          // Modification : 
    321          // INCLUDE:         #include "_TypeCible.h", "CLCommunic.h" 
    322          // Prototype:       UC ucLireNbCaractRecu(void);
    323          //
    324          // Description:     Fonction qui retourne le nombre de caractere recu. 
    325          //                  
    326          //
    327          // Parametre d'entree: aucun 
    328          //                     
    329          //
    330          // Parametre de sortie: ucNombreCaractere: nombre de caractere recu.
    331          //
    332          // Procedure appelees: aucune.
    333          //                     
    334          // Exemple d'appel: if(ucLireNbCaractRecu() < (ucLongueurTrame -1))
    335          //*****************************************************************************

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    336          UC CLCommunic :: ucLireNbCaractRecu(void)
   \                     ??ucLireNbCaractRecu:
    337          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    338          return(ucNbCaractRecu);          // Retourne le nombre de caractere recu.
   \   000004   90....       MOV     DPTR,#??ucNbCaractRecu
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009   D083         POP     DPH
   \   00000B   D082         POP     DPL
   \   00000D   22           RET
    339          }
    340          //*****************************************************************************
    341          // Nom de la fct:   ucLireEtatTrame                  Fait par: Philippe Dubois
    342          // Date:            2 octobre 2013             
    343          // Revision :       A      
    344          // Modification : 
    345          // INCLUDE:        #include "_TypeCible.h", "CLCommunic.h" 
    346          // Prototype:       UC ucLireEtatTrame(void);
    347          //
    348          // Description:     Fonction qui permet de savoir si une trame est complete. 
    349          //                  
    350          //
    351          // Parametre d'entree: aucun 
    352          //                     
    353          //
    354          // Parametre de sortie: ucEtatTrameRecu: a 1 pour complete et 0 si imcomplete.
    355          //
    356          // Procedure appelees: aucune.
    357          //                     
    358          // Exemple d'appel:if(ucLireEtatTrame()==TRAMECOMPLET) 
    359          //*****************************************************************************

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    360          UC CLCommunic :: ucLireEtatTrame(void)
   \                     ??ucLireEtatTrame:
    361          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    362          return(ucEtatTrame);            // Retourne l'etat de la trame.
   \   000004   90....       MOV     DPTR,#??ucEtatTrame
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009   D083         POP     DPH
   \   00000B   D082         POP     DPL
   \   00000D   22           RET
    363          }
    364          //*****************************************************************************
    365          // Nom de la fct:   *ucpLireTrame                   Fait par: Philippe Dubois
    366          // Date:            2 octobre 2013             
    367          // Revision :       A      
    368          // Modification : 
    369          // INCLUDE:         #include "_TypeCible.h", "CLCommunic.h" 
    370          // Prototype:       UI *ucpLireTrame(void);
    371          //
    372          // Description:     Fonction qui permet de transmettre l'adresse du tableau 
    373          //                  contenant la trame de caractere, et reinitialiser l'etat  
    374          //                  de la  trame.
    375          //
    376          // Parametre d'entree: aucun 
    377          //                     
    378          //
    379          // Parametre de sortie: uiTab: adresse du tableau.
    380          //
    381          // Procedure appelees: ucValideTrame()
    382          //                     
    383          // Exemple d'appel:vTransCaratere('A') 
    384          //*****************************************************************************

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    385          char *CLCommunic :: ucpLireTrame(void)
   \                     ??ucpLireTrame:
    386          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    387          char *ucptrLectAEnvoyer;           // Pointeur sur la trame recue.
    388          ucEtatTrame = INCOMPLET;           // Reinitialise l'etat de la trame.
   \   000004   90....       MOV     DPTR,#??ucEtatTrame
   \   000007   7400         MOV     A,#0x0
   \   000009   F0           MOVX    @DPTR,A
    389          
    390          if(ucValideTrame() == VRAI)        // Verifie si la trame est valide.
   \   00000A                ; Setup parameters for call to function CLCommunic::ucValideTrame()
   \   00000A   12....       LCALL   ??ucValideTrame
   \   00000D   E9           MOV     A,R1
   \   00000E   6401         XRL     A,#0x1
   \   000010   700A         JNZ     ??ucpLireTrame_1
    391            {                                // Si elle l'est 
    392             ucptrLectAEnvoyer = cptrLecture;// transmet l'adresse du debut de la trame.
   \   000012   90....       MOV     DPTR,#??cptrLecture
   \   000015   E0           MOVX    A,@DPTR
   \   000016   FA           MOV     R2,A
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   FB           MOV     R3,A
   \   00001A   8004         SJMP    ??ucpLireTrame_2
    393            }
    394          else                               // Sinon
    395            {
    396             ucptrLectAEnvoyer = NULL;       // Ne transmet pas l'adresse du debut de 
   \                     ??ucpLireTrame_1:
   \   00001C   7A00         MOV     R2,#0x0
   \   00001E   7B00         MOV     R3,#0x0
    397            }                                // la trame.
    398          return(ucptrLectAEnvoyer);         // Retourne l'adresse du tableau ou NULL. 
   \                     ??ucpLireTrame_2:
   \   000020   D083         POP     DPH
   \   000022   D082         POP     DPL
   \   000024   22           RET
    399          }
    400          //*****************************************************************************
    401          // Nom de la fct:   vInitBaudRate                  Fait par: Philippe Dubois
    402          // Date:            2 octobre 2013         version base
    403          //                  10 avril 2014          version avec uPSD.
    404          // Revision :       B      
    405          // Modification : 
    406          // INCLUDE:         #include "_TypeCible.h", "CLCommunic.h" 
    407          // Prototype:       void vInitBaudRate(UI uiBaud);
    408          //
    409          // Description:     Fonction qui permet d' initialiser le port srie au 
    410          //                  baudrate desire, le timer 1(8 bit auto reload) et  
    411          //                  les interuptions necessaire pour communiquer avec 
    412          //                  le port serie.
    413          //                  Ajout de la compilation conditionnelle pour choix
    414          //                  de la valeur a mettre dans TH1 selon la cible.
    415          //
    416          // Parametre d'entree: UI uiBaud: pour determine la vitesse du baudrate. 
    417          //                     
    418          //
    419          // Parametre de sortie: aucune
    420          //
    421          // Procedure appelees: aucune.
    422          //                     
    423          // Exemple d'appel: vInitBaudRate(57600);
    424          //*****************************************************************************

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    425          void CLCommunic:: vInitBaudRate(UI uiBaud)
   \                     ??vInitBaudRate:
    426          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    427          SCON0 = 0x50;         // SM0_0=0 
   \   000005   759850       MOV     0x98,#0x50
    428                                // SM1_0=1
    429                                // SM2_0=0 pour longeur 10 bits et asychrone.
    430                                // REN_0=1 pour recevoir des caracteres.
    431          TMOD = TMOD | 0x20;   // M1=1
   \   000008   438920       ORL     0x89,#0x20
    432                                // M0=0 pour timer 8bit avec autoreload.
    433          PCON = PCON | 0x80;   // Pour doubler le baudrate (SMOD_0=1;).
   \   00000B   438780       ORL     0x87,#0x80
    434          
    435          #ifdef DALLAS89C450   // Si la cible est le Dallas
    436          
    437          switch(uiBaud)         // switch case pour determiner la valeur en 
    438            {                    // hexa qui faut mettre a TH1 pour avoir la 
    439                             // bonne vitesse du timer pour generer
    440             case 57600:         // le baudrate.
    441                TH1= 0xFF;
    442             break;
    443             case 38400:
    444                TH1= 0xFE;
    445             break;
    446             case 19200:
    447                TH1= 0xFD;
    448             break;
    449             case 9600:
    450                TH1= 0xFA;
    451             break;
    452             case 4800:
    453                TH1= 0xF4;
    454             break;
    455             case 2400:
    456                TH1= 0xE8;
    457             break;
    458             default:
    459                TH1= 0xFA;        // Si aucune valeur ne correspond vitesse = 9600 .
    460             break; 
    461            }
    462          #endif
    463           
    464          #ifdef UPSD3254A        // Si la cible est le uPSD
    465          
    466          switch(uiBaud)         // switch case pour determiner la valeur en 
   \   00000E   8C..         MOV     ?V0 + 0,R4
   \   000010   8D..         MOV     ?V0 + 1,R5
   \   000012   78..         MOV     R0,#?V0 + 0
   \   000014   12....       LCALL   ?US_SWITCH_SPARSE
   \                     `?<Jumptable for vInitBaudRate>_0`:
   \   000017   0000         DW        0
   \   000019   0300         DW        3
   \   00001B   6009         DW        2400
   \   00001D   ....         DW        ??vInitBaudRate_1
   \   00001F   C012         DW        4800
   \   000021   ....         DW        ??vInitBaudRate_2
   \   000023   8025         DW        9600
   \   000025   ....         DW        ??vInitBaudRate_3
   \   000027   ....         DW        ??vInitBaudRate_4
    467            {                    // hexa qui faut mettre a TH1 pour avoir la 
    468                            // bonne vitesse du timer pour generer
    469              /*case 57600:      // le baudrate.
    470              TH1= 0xFE ;
    471              break;
    472              case 38400:        // uPSD ne peut aller a ces vitesses
    473              TH1= 0xFD;
    474              break;
    475              case 19200:
    476              TH1= 0xF9;
    477              break;*/
    478              case 9600:
    479                 TH1= 0xF3;
   \                     ??vInitBaudRate_3:
   \   000029   758DF3       MOV     0x8d,#-0xd
    480              break;
   \   00002C   800D         SJMP    ??vInitBaudRate_5
    481              case 4800:
    482                 TH1= 0xE6;
   \                     ??vInitBaudRate_2:
   \   00002E   758DE6       MOV     0x8d,#-0x1a
    483              break;
   \   000031   8008         SJMP    ??vInitBaudRate_5
    484              case 2400:
    485                 TH1= 0xCC;
   \                     ??vInitBaudRate_1:
   \   000033   758DCC       MOV     0x8d,#-0x34
    486              break;
   \   000036   8003         SJMP    ??vInitBaudRate_5
    487              default:
    488                 TH1= 0xF3;         // Si aucune valeur ne correspond vitesse = 9600 .
   \                     ??vInitBaudRate_4:
   \   000038   758DF3       MOV     0x8d,#-0xd
    489              break; 
    490            }
    491          #endif 
    492           
    493          TR1  = 1;      // Active le timer 1.
   \                     ??vInitBaudRate_5:
   \   00003B   D28E         SETB    0x88.6
    494          ET1  = 0;      // Desactive les interruptions du timer 1. 
   \   00003D   C2AB         CLR     0xa8.3
    495          EA   = 1;      // Active les interruptions.
   \   00003F   D2AF         SETB    0xa8.7
    496          ES   = 1;      // Active les interruptions du port serie.
   \   000041   D2AC         SETB    0xa8.4
    497          TI_0 = 0;      // Met a 0 le drapeau de la transmision serie.
   \   000043   C299         CLR     0x98.1
    498          }
   \   000045   7F02         MOV     R7,#0x2
   \   000047   02....       LJMP    ?FUNC_LEAVE_XDATA
   \   00004A                REQUIRE _A_SCON
   \   00004A                REQUIRE _A_TMOD
   \   00004A                REQUIRE _A_PCON
   \   00004A                REQUIRE TH1
   \   00004A                REQUIRE _A_TCON
   \   00004A                REQUIRE _A_IE
    499          
    500          //*****************************************************************************
    501          // Nom de la fct:   vInteruptSerial                  Fait par: Philippe Dubois
    502          // Date:            2 octobre 2013 
    503          //                  
    504          // Revision :       B      
    505          // Modification :   10 avril 2014     conversion pour IAR
    506          //
    507          // INCLUDE:         #include "_TypeCible.h", "CLCommunic.h" 
    508          // Prototype:       __interrupt  void CLCommunic:: vInteruptSerial(void);
    509          //
    510          // Description:     Fonction qui permet de recevoir des caracteres par le port 
    511          //                  serie, si l'interruption vient de la reception on place
    512          //                  les caracteres lus dans un tableau.
    513          //
    514          // Parametre d'entree: aucun.
    515          //                     
    516          //
    517          // Parametre de sortie: valeur dans cptrLecture pour lire les caractere recus.
    518          //
    519          // Procedure appelees: ucLireNbCaractRecu(),
    520          //                     
    521          // Exemple d'appel: aucun 
    522          //*****************************************************************************
    523          #pragma vector=0x23  // Interrupt 4 pour interruption serie au vecteur 23                                  

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    524           __interrupt  void CLCommunic:: vInteruptSerial(void) 
   \                     ??vInteruptSerial:
    525          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 15
   \   000007                ; Auto size: 0
    526          EA = 0;                               // Desactive les interruptions.
   \   000007   C2AF         CLR     0xa8.7
    527          
    528          if(RI_0==1)                           // Interruption cause par la reception?
   \   000009   A298         MOV     C,0x98.0
   \   00000B   4003         JC      $+5
   \   00000D   02....       LJMP    ??vInteruptSerial_1
    529            {
    530             if(cptrEcriture > cpFinTrame)      // Si on a atteind la fin du buffer
   \   000010   90....       MOV     DPTR,#??cpFinTrame
   \   000013   C082         PUSH    DPL
   \   000015   C083         PUSH    DPH
   \   000017   90....       MOV     DPTR,#??cptrEcriture
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F8           MOV     R0,A
   \   00001C   A3           INC     DPTR
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   F9           MOV     R1,A
   \   00001F   D083         POP     DPH
   \   000021   D082         POP     DPL
   \   000023   C3           CLR     C
   \   000024   E0           MOVX    A,@DPTR
   \   000025   98           SUBB    A,R0
   \   000026   A3           INC     DPTR
   \   000027   E0           MOVX    A,@DPTR
   \   000028   99           SUBB    A,R1
   \   000029   5010         JNC     ??vInteruptSerial_2
    531               {
    532                cptrEcriture = cpDebutTrame;    // Retourne au debut du tampon.
   \   00002B   90....       MOV     DPTR,#??cpDebutTrame
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   F8           MOV     R0,A
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   F9           MOV     R1,A
   \   000033   90....       MOV     DPTR,#??cptrEcriture
   \   000036   E8           MOV     A,R0
   \   000037   F0           MOVX    @DPTR,A
   \   000038   A3           INC     DPTR
   \   000039   E9           MOV     A,R1
   \   00003A   F0           MOVX    @DPTR,A
    533               }      
    534               
    535            *cptrEcriture    = SBUF0;  // Lit dans SBUF0 le caractere recu et met dans le tableau.                               
   \                     ??vInteruptSerial_2:
   \   00003B   E599         MOV     A,0x99
   \   00003D   C0E0         PUSH    A
   \   00003F   90....       MOV     DPTR,#??cptrEcriture
   \   000042   E0           MOVX    A,@DPTR
   \   000043   F8           MOV     R0,A
   \   000044   A3           INC     DPTR
   \   000045   E0           MOVX    A,@DPTR
   \   000046   F583         MOV     DPH,A
   \   000048   8882         MOV     DPL,R0
   \   00004A   D0E0         POP     A
   \   00004C   F0           MOVX    @DPTR,A
    536             ucCaractereRecu = SBUF0;
   \   00004D   E599         MOV     A,0x99
   \   00004F   90....       MOV     DPTR,#??ucCaractereRecu
   \   000052   F0           MOVX    @DPTR,A
    537             ucEtatReception = ACTIF;
   \   000053   90....       MOV     DPTR,#??ucEtatReception
   \   000056   7401         MOV     A,#0x1
   \   000058   F0           MOVX    @DPTR,A
    538             cptrEcriture++;           // Increment la position du pointeur d'ecriture.
   \   000059   90....       MOV     DPTR,#??cptrEcriture
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   2401         ADD     A,#0x1
   \   00005F   F8           MOV     R0,A
   \   000060   A3           INC     DPTR
   \   000061   E0           MOVX    A,@DPTR
   \   000062   3400         ADDC    A,#0x0
   \   000064   F9           MOV     R1,A
   \   000065   90....       MOV     DPTR,#??cptrEcriture
   \   000068   E8           MOV     A,R0
   \   000069   F0           MOVX    @DPTR,A
   \   00006A   A3           INC     DPTR
   \   00006B   E9           MOV     A,R1
   \   00006C   F0           MOVX    @DPTR,A
    539              
    540             if(ucLireNbCaractRecu() < (ucLongueurTrame - 1) )
   \   00006D                ; Setup parameters for call to function CLCommunic::ucLireNbCaractRecu()
   \   00006D   12....       LCALL   ??ucLireNbCaractRecu
   \   000070   E9           MOV     A,R1
   \   000071   FA           MOV     R2,A
   \   000072   7B00         MOV     R3,#0x0
   \   000074   90....       MOV     DPTR,#??ucLongueurTrame
   \   000077   E0           MOVX    A,@DPTR
   \   000078   F8           MOV     R0,A
   \   000079   7900         MOV     R1,#0x0
   \   00007B   24FF         ADD     A,#-0x1
   \   00007D   F8           MOV     R0,A
   \   00007E   E9           MOV     A,R1
   \   00007F   34FF         ADDC    A,#-0x1
   \   000081   F9           MOV     R1,A
   \   000082   C3           CLR     C
   \   000083   EA           MOV     A,R2
   \   000084   98           SUBB    A,R0
   \   000085   EB           MOV     A,R3
   \   000086   99           SUBB    A,R1
   \   000087   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000089   65D0         XRL     A,PSW
   \   00008B   33           RLC     A
   \   00008C   5009         JNC     ??vInteruptSerial_3
    541               {                       // Si le nombre de caractere recu est inferieur a 
    542                ucNbCaractRecu++;      // trame - 1 incremente le nombre de caracteres 
   \   00008E   90....       MOV     DPTR,#??ucNbCaractRecu
   \   000091   E0           MOVX    A,@DPTR
   \   000092   2401         ADD     A,#0x1
   \   000094   F0           MOVX    @DPTR,A
   \   000095   802C         SJMP    ??vInteruptSerial_4
    543               }                       // recus.
    544             else                      // Si la trame est complete?
    545               {
    546                ucNbCaractRecu=0;      // Remet a 0 le compte de caractere.
   \                     ??vInteruptSerial_3:
   \   000097   90....       MOV     DPTR,#??ucNbCaractRecu
   \   00009A   7400         MOV     A,#0x0
   \   00009C   F0           MOVX    @DPTR,A
    547                ucEtatTrame = COMPLET; // Indique qu'une trame est complete.
   \   00009D   90....       MOV     DPTR,#??ucEtatTrame
   \   0000A0   7401         MOV     A,#0x1
   \   0000A2   F0           MOVX    @DPTR,A
    548                cptrLecture = (cptrEcriture - (ucLongueurTrame)); 
   \   0000A3   90....       MOV     DPTR,#??ucLongueurTrame
   \   0000A6   E0           MOVX    A,@DPTR
   \   0000A7   F8           MOV     R0,A
   \   0000A8   7900         MOV     R1,#0x0
   \   0000AA   C3           CLR     C
   \   0000AB   E4           CLR     A
   \   0000AC   98           SUBB    A,R0
   \   0000AD   F8           MOV     R0,A
   \   0000AE   E4           CLR     A
   \   0000AF   99           SUBB    A,R1
   \   0000B0   F9           MOV     R1,A
   \   0000B1   90....       MOV     DPTR,#??cptrEcriture
   \   0000B4   E0           MOVX    A,@DPTR
   \   0000B5   28           ADD     A,R0
   \   0000B6   F8           MOV     R0,A
   \   0000B7   A3           INC     DPTR
   \   0000B8   E0           MOVX    A,@DPTR
   \   0000B9   39           ADDC    A,R1
   \   0000BA   F9           MOV     R1,A
   \   0000BB   90....       MOV     DPTR,#??cptrLecture
   \   0000BE   E8           MOV     A,R0
   \   0000BF   F0           MOVX    @DPTR,A
   \   0000C0   A3           INC     DPTR
   \   0000C1   E9           MOV     A,R1
   \   0000C2   F0           MOVX    @DPTR,A
    549                                       // Le pointeur de lecture = la position 
    550                                       // d'ecriture - la longuer de la trame.
    551               }
    552             RI_0 = 0;                 // Reinitialiser le flag de reception.
   \                     ??vInteruptSerial_4:
   \   0000C3   C298         CLR     0x98.0
    553           }                           // Fin du if(RI_0 = 1)
    554          EA = 1;                      // Reactive les interruptions
   \                     ??vInteruptSerial_1:
   \   0000C5   D2AF         SETB    0xa8.7
    555          }                            // Fin de Interruption.
   \   0000C7   7F01         MOV     R7,#0x1
   \   0000C9   02....       LJMP    ?INTERRUPT_LEAVE_XSP
   \   0000CC                REQUIRE _A_IE
   \   0000CC                REQUIRE _A_SCON
   \   0000CC                REQUIRE SBUF
    556          
    557          //*****************************************************************************
    558          // Nom de la fct:   vTransChiffre
    559          // Description:     Fonction qui permet transmettre  un nombre de 0 a 
    560          //                  65000 sur le port serie.
    561          // INCLUDE:       #include "_TypeCible.h", "CLCommunic.h" 
    562          // Prototype:     void vTransChiffre(UI uiChiffreAAfficher);
    563          //
    564          //
    565          // Parametre d'entree: uiChiffreAAfficher pour chiffre a afficher
    566          //                     
    567          // Parametre de sortie: aucun
    568          //
    569          // Procedure appelees: vTransCaratere();
    570          //                     
    571          //
    572          // Exemple d'appel: vLcdAffChiffre(12345)
    573          //
    574          // Fait par: Philippe Dubois
    575          // Date:            14 novembre 2013             
    576          // Revision :       A      
    577          // Modification : 
    578          //*****************************************************************************

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    579          void CLCommunic :: vTransChiffre(UI uiChiffreAAfficher)
   \                     ??vTransChiffre:
    580          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
    581          UC ucChiffre0; // Declaration des variables
    582          UC ucChiffre1;
    583          UC ucChiffre2;
    584          UC ucChiffre3;
    585          UC ucChiffre4; // isole chaque chiffre du nombre.
    586          
    587          ucChiffre0 = ((uiChiffreAAfficher  % 10)    + 0x30);       // Unitee.  
   \   000009   EC           MOV     A,R4
   \   00000A   F8           MOV     R0,A
   \   00000B   ED           MOV     A,R5
   \   00000C   F9           MOV     R1,A
   \   00000D   7A0A         MOV     R2,#0xa
   \   00000F   7B00         MOV     R3,#0x0
   \   000011   12....       LCALL   ?US_DIV_MOD
   \   000014   EA           MOV     A,R2
   \   000015   2430         ADD     A,#0x30
   \   000017   F5..         MOV     ?V0 + 2,A
    588          ucChiffre1 = (((uiChiffreAAfficher / 10)    % 10) + 0x30); // Dizaine
   \   000019   EC           MOV     A,R4
   \   00001A   F8           MOV     R0,A
   \   00001B   ED           MOV     A,R5
   \   00001C   F9           MOV     R1,A
   \   00001D   7A0A         MOV     R2,#0xa
   \   00001F   7B00         MOV     R3,#0x0
   \   000021   12....       LCALL   ?US_DIV_MOD
   \   000024   7A0A         MOV     R2,#0xa
   \   000026   7B00         MOV     R3,#0x0
   \   000028   12....       LCALL   ?US_DIV_MOD
   \   00002B   EA           MOV     A,R2
   \   00002C   2430         ADD     A,#0x30
   \   00002E   F5..         MOV     ?V0 + 1,A
    589          ucChiffre2 = (((uiChiffreAAfficher / 100)   % 10) + 0x30); // Centaine.        
   \   000030   EC           MOV     A,R4
   \   000031   F8           MOV     R0,A
   \   000032   ED           MOV     A,R5
   \   000033   F9           MOV     R1,A
   \   000034   7A64         MOV     R2,#0x64
   \   000036   7B00         MOV     R3,#0x0
   \   000038   12....       LCALL   ?US_DIV_MOD
   \   00003B   7A0A         MOV     R2,#0xa
   \   00003D   7B00         MOV     R3,#0x0
   \   00003F   12....       LCALL   ?US_DIV_MOD
   \   000042   EA           MOV     A,R2
   \   000043   2430         ADD     A,#0x30
   \   000045   F5..         MOV     ?V0 + 0,A
    590          ucChiffre3 = (((uiChiffreAAfficher / 1000)  % 10) + 0x30); // Millier.
   \   000047   EC           MOV     A,R4
   \   000048   F8           MOV     R0,A
   \   000049   ED           MOV     A,R5
   \   00004A   F9           MOV     R1,A
   \   00004B   7AE8         MOV     R2,#-0x18
   \   00004D   7B03         MOV     R3,#0x3
   \   00004F   12....       LCALL   ?US_DIV_MOD
   \   000052   7A0A         MOV     R2,#0xa
   \   000054   7B00         MOV     R3,#0x0
   \   000056   12....       LCALL   ?US_DIV_MOD
   \   000059   EA           MOV     A,R2
   \   00005A   2430         ADD     A,#0x30
   \   00005C   FE           MOV     R6,A
    591          ucChiffre4 = ((uiChiffreAAfficher  / 10000) + 0x30);       // Dizaine de mille.
   \   00005D   EC           MOV     A,R4
   \   00005E   F8           MOV     R0,A
   \   00005F   ED           MOV     A,R5
   \   000060   F9           MOV     R1,A
   \   000061   7A10         MOV     R2,#0x10
   \   000063   7B27         MOV     R3,#0x27
   \   000065   12....       LCALL   ?US_DIV_MOD
   \   000068   E8           MOV     A,R0
   \   000069   2430         ADD     A,#0x30
   \   00006B   FF           MOV     R7,A
    592          
    593          if(ucChiffre4 != 0x30)                          // Si Dizaine de mille  = 0
   \   00006C   7430         MOV     A,#0x30
   \   00006E   6F           XRL     A,R7
   \   00006F   6009         JZ      ??vTransChiffre_1
    594            {                                           // Ne l'affiche pas 
    595             vTransCaratere(ucChiffre4);                  // Transmet les Dizaine de mille. 
   \   000071                ; Setup parameters for call to function CLCommunic::vTransCaratere(UC)
   \   000071   EF           MOV     A,R7
   \   000072   F9           MOV     R1,A
   \   000073   AA82         MOV     R2,DPL
   \   000075   AB83         MOV     R3,DPH
   \   000077   12....       LCALL   ??vTransCaratere
    596            }
    597          
    598          if((ucChiffre4 != 0x30) || (ucChiffre3 != 0x30))// Si les 2 premiers chiffres
   \                     ??vTransChiffre_1:
   \   00007A   7430         MOV     A,#0x30
   \   00007C   6F           XRL     A,R7
   \   00007D   7005         JNZ     ??vTransChiffre_2
   \   00007F   7430         MOV     A,#0x30
   \   000081   6E           XRL     A,R6
   \   000082   6009         JZ      ??vTransChiffre_3
    599            {                                             // sont different de 0.
    600             vTransCaratere(ucChiffre3);                  // Transmet les millier.
   \                     ??vTransChiffre_2:
   \   000084                ; Setup parameters for call to function CLCommunic::vTransCaratere(UC)
   \   000084   EE           MOV     A,R6
   \   000085   F9           MOV     R1,A
   \   000086   AA82         MOV     R2,DPL
   \   000088   AB83         MOV     R3,DPH
   \   00008A   12....       LCALL   ??vTransCaratere
    601            }   
    602          
    603          if((ucChiffre4 != 0x30) || (ucChiffre3 != 0x30)||(ucChiffre2 != 0x30))
   \                     ??vTransChiffre_3:
   \   00008D   7430         MOV     A,#0x30
   \   00008F   6F           XRL     A,R7
   \   000090   700B         JNZ     ??vTransChiffre_4
   \   000092   7430         MOV     A,#0x30
   \   000094   6E           XRL     A,R6
   \   000095   7006         JNZ     ??vTransChiffre_4
   \   000097   7430         MOV     A,#0x30
   \   000099   65..         XRL     A,?V0 + 0
   \   00009B   6009         JZ      ??vTransChiffre_5
    604            {                                  // Si les 3 1er chiffres sont different 
    605                                                 // de 0?    
    606             vTransCaratere(ucChiffre2);         // Transmet les centaines.
   \                     ??vTransChiffre_4:
   \   00009D                ; Setup parameters for call to function CLCommunic::vTransCaratere(UC)
   \   00009D   A9..         MOV     R1,?V0 + 0
   \   00009F   AA82         MOV     R2,DPL
   \   0000A1   AB83         MOV     R3,DPH
   \   0000A3   12....       LCALL   ??vTransCaratere
    607            }
    608          
    609          if((ucChiffre4 != 0x30)||(ucChiffre3 != 0x30)||(ucChiffre2 != 0x30)||(ucChiffre1 != 0x30)) 
   \                     ??vTransChiffre_5:
   \   0000A6   7430         MOV     A,#0x30
   \   0000A8   6F           XRL     A,R7
   \   0000A9   7011         JNZ     ??vTransChiffre_6
   \   0000AB   7430         MOV     A,#0x30
   \   0000AD   6E           XRL     A,R6
   \   0000AE   700C         JNZ     ??vTransChiffre_6
   \   0000B0   7430         MOV     A,#0x30
   \   0000B2   65..         XRL     A,?V0 + 0
   \   0000B4   7006         JNZ     ??vTransChiffre_6
   \   0000B6   7430         MOV     A,#0x30
   \   0000B8   65..         XRL     A,?V0 + 1
   \   0000BA   6009         JZ      ??vTransChiffre_7
    610                                            // Si les 4 premier chiffres sont 
    611            {                                    // different de 0.
    612             vTransCaratere(ucChiffre1);         // Transmet les dizianes.
   \                     ??vTransChiffre_6:
   \   0000BC                ; Setup parameters for call to function CLCommunic::vTransCaratere(UC)
   \   0000BC   A9..         MOV     R1,?V0 + 1
   \   0000BE   AA82         MOV     R2,DPL
   \   0000C0   AB83         MOV     R3,DPH
   \   0000C2   12....       LCALL   ??vTransCaratere
    613            }        
    614           vTransCaratere(ucChiffre0);           // Transmetles unitees.
   \                     ??vTransChiffre_7:
   \   0000C5                ; Setup parameters for call to function CLCommunic::vTransCaratere(UC)
   \   0000C5   A9..         MOV     R1,?V0 + 2
   \   0000C7   AA82         MOV     R2,DPL
   \   0000C9   AB83         MOV     R3,DPH
   \   0000CB   12....       LCALL   ??vTransCaratere
    615          }   
   \   0000CE   7F03         MOV     R7,#0x3
   \   0000D0   02....       LJMP    ?FUNC_LEAVE_XDATA
    616             

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    617          UC CLCommunic :: ucLireTrameSansCheck(void)
   \                     ??ucLireTrameSansCheck:
    618          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    619          ucEtatReception = INACTIF;
   \   000004   90....       MOV     DPTR,#??ucEtatReception
   \   000007   7400         MOV     A,#0x0
   \   000009   F0           MOVX    @DPTR,A
    620          return(ucCaractereRecu);      
   \   00000A   90....       MOV     DPTR,#??ucCaractereRecu
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F9           MOV     R1,A
   \   00000F   D083         POP     DPH
   \   000011   D082         POP     DPL
   \   000013   22           RET
    621          }
    622          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    623          UC CLCommunic :: ucLireEtatReception(void)
   \                     ??ucLireEtatReception:
    624          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    625          return(ucEtatReception);            // Retourne l'etat de la trame.
   \   000004   90....       MOV     DPTR,#??ucEtatReception
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009   D083         POP     DPH
   \   00000B   D082         POP     DPL
   \   00000D   22           RET
    626          }

   \                                 In  segment INTVEC, offset 0x23, root
   \                     `??vInteruptSerial??INTVEC 35`:
   \   000023   02....       LJMP       (??vInteruptSerial)

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ucLongueurTrame>`:
   \   000000   04           DB 4

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ucLongueurTampon>`:
   \   000000   0C           DB 12

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \   __near_func __xdata_reentrant CLCommunic &CLCommunic::new CLCommunic()
   \                     `??new CLCommunic`:
   \   000000   C0..         PUSH    ?V0 + 0
   \   000002   C0..         PUSH    ?V0 + 1
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004                ; Setup parameters for call to function operator new(unsigned int)
   \   000004   7A01         MOV     R2,#0x1
   \   000006   7B00         MOV     R3,#0x0
   \   000008   12....       LCALL   `??operator new`
   \   00000B   8A..         MOV     ?V0 + 0,R2
   \   00000D   8B..         MOV     ?V0 + 1,R3
   \   00000F   A8..         MOV     R0,?V0 + 0
   \   000011   A9..         MOV     R1,?V0 + 1
   \   000013   E8           MOV     A,R0
   \   000014   FA           MOV     R2,A
   \   000015   E9           MOV     A,R1
   \   000016   FB           MOV     R3,A
   \   000017   E8           MOV     A,R0
   \   000018   49           ORL     A,R1
   \   000019   600D         JZ      `??new CLCommunic_2`
   \   00001B                ; Setup parameters for call to function CLCommunic::CLCommunic()
   \   00001B   12....       LCALL   ??CLCommunic
   \   00001E   8A..         MOV     ?V0 + 0,R2
   \   000020   8B..         MOV     ?V0 + 1,R3
   \   000022   AA..         MOV     R2,?V0 + 0
   \   000024   AB..         MOV     R3,?V0 + 1
   \   000026   8004         SJMP    `??new CLCommunic_3`
   \                     `??new CLCommunic_2`:
   \   000028   7A00         MOV     R2,#0x0
   \   00002A   7B00         MOV     R3,#0x0
   \                     `??new CLCommunic_3`:
   \   00002C   D0..         POP     ?V0 + 1
   \   00002E   D0..         POP     ?V0 + 0
   \   000030   22           RET

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \   __near_func __xdata_reentrant CLCommunic &CLCommunic::new CLCommunic(UC, UC, UI)
   \                     `??new CLCommunic_1`:
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   \   000007   EA           MOV     A,R2
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0 + 0,R4
   \   00000B   8D..         MOV     ?V0 + 1,R5
   \   00000D                ; Setup parameters for call to function operator new(unsigned int)
   \   00000D   7A01         MOV     R2,#0x1
   \   00000F   7B00         MOV     R3,#0x0
   \   000011   12....       LCALL   `??operator new`
   \   000014   8A..         MOV     ?V0 + 2,R2
   \   000016   8B..         MOV     ?V0 + 3,R3
   \   000018   A8..         MOV     R0,?V0 + 2
   \   00001A   A9..         MOV     R1,?V0 + 3
   \   00001C   E8           MOV     A,R0
   \   00001D   FA           MOV     R2,A
   \   00001E   E9           MOV     A,R1
   \   00001F   FB           MOV     R3,A
   \   000020   E8           MOV     A,R0
   \   000021   49           ORL     A,R1
   \   000022   601B         JZ      `??new CLCommunic_4`
   \   000024                ; Setup parameters for call to function CLCommunic::CLCommunic(UC, UC, UI)
   \   000024   78..         MOV     R0,#?V0 + 0
   \   000026   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000029   EF           MOV     A,R7
   \   00002A   FC           MOV     R4,A
   \   00002B   EE           MOV     A,R6
   \   00002C   F9           MOV     R1,A
   \   00002D   12....       LCALL   ??CLCommunic_1
   \   000030   7402         MOV     A,#0x2
   \   000032   12....       LCALL   ?DEALLOC_XSTACK8
   \   000035   8A..         MOV     ?V0 + 0,R2
   \   000037   8B..         MOV     ?V0 + 1,R3
   \   000039   AA..         MOV     R2,?V0 + 0
   \   00003B   AB..         MOV     R3,?V0 + 1
   \   00003D   8004         SJMP    `??new CLCommunic_5`
   \                     `??new CLCommunic_4`:
   \   00003F   7A00         MOV     R2,#0x0
   \   000041   7B00         MOV     R3,#0x0
   \                     `??new CLCommunic_5`:
   \   000043   7F04         MOV     R7,#0x4
   \   000045   02....       LJMP    ?FUNC_LEAVE_XDATA

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \   __near_func __xdata_reentrant void CLCommunic::delete ~CLCommunic(CLCommunic *)
   \                     `??delete ~CLCommunic`:
   \   000000   74F8         MOV     A,#-0x8
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 8
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   EE           MOV     A,R6
   \   00000A   4F           ORL     A,R7
   \   00000B   600E         JZ      `??delete ~CLCommunic_1`
   \   00000D                ; Setup parameters for call to function CLCommunic::~CLCommunic()
   \   00000D   EE           MOV     A,R6
   \   00000E   FA           MOV     R2,A
   \   00000F   EF           MOV     A,R7
   \   000010   FB           MOV     R3,A
   \   000011   12....       LCALL   `?~CLCommunic`
   \   000014                ; Setup parameters for call to function operator delete(void *)
   \   000014   EE           MOV     A,R6
   \   000015   FA           MOV     R2,A
   \   000016   EF           MOV     A,R7
   \   000017   FB           MOV     R3,A
   \   000018   12....       LCALL   `??operator delete`
   \                     `??delete ~CLCommunic_1`:
   \   00001B   7F01         MOV     R7,#0x1
   \   00001D   02....       LJMP    ?FUNC_LEAVE_XDATA
    627          
    628          
    629          //LinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxTUX
    630          
    631          
    632          
    633          
    634          
    635          

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     CLCommunic::CLCommunic()           0      0      8
       -> operator new[](unsigned int)
                                        0      0     16
       -> CLCommunic::vInitBaudRate(UI)
                                        0      0     16
     CLCommunic::CLCommunic(UC, UC, UI)
                                        0      0     26
       -> operator new[](unsigned int)
                                        0      0     26
       -> CLCommunic::ucInitLongTrame(UC)
                                        0      0     26
       -> CLCommunic::vInitBaudRate(UI)
                                        0      0     26
     CLCommunic::delete ~CLCommunic(CLCommunic *)
                                        0      0      8
       -> CLCommunic::~CLCommunic()     0      0     16
       -> operator delete(void *)       0      0     16
     CLCommunic::new CLCommunic()       2      0      0
       -> operator new(unsigned int)
                                        4      0      0
       -> CLCommunic::CLCommunic()      4      0      0
     CLCommunic::new CLCommunic(UC, UC, UI)
                                        0      0     13
       -> operator new(unsigned int)
                                        0      0     22
       -> CLCommunic::CLCommunic(UC, UC, UI)
                                        0      0     26
     CLCommunic::ucInitLongTrame(UC)
                                        2      0     13
     CLCommunic::ucLireEtatReception()
                                        2      0      0
     CLCommunic::ucLireEtatTrame()      2      0      0
     CLCommunic::ucLireNbCaractRecu()
                                        2      0      0
     CLCommunic::ucLireTrameSansCheck()
                                        2      0      0
     CLCommunic::ucValideTrame()        2      0      0
     CLCommunic::ucpLireTrame()         2      0      0
       -> CLCommunic::ucValideTrame()
                                        4      0      0
     CLCommunic::vAffChaine(char const *)
                                        0      0      8
       -> CLCommunic::vTransCaratere(UC)
                                        0      0     16
     CLCommunic::vInitBaudRate(UI)      0      0     22
     CLCommunic::vInteruptSerial()     17      0      0
       -> CLCommunic::ucLireNbCaractRecu()
                                       30      0      0
     CLCommunic::vTransCaratere(UC)     0      0     10
     CLCommunic::vTransChiffre(UI)      0      0     10
       -> CLCommunic::vTransCaratere(UC)
                                        0      0     20
       -> CLCommunic::vTransCaratere(UC)
                                        0      0     20
       -> CLCommunic::vTransCaratere(UC)
                                        0      0     20
       -> CLCommunic::vTransCaratere(UC)
                                        0      0     20
       -> CLCommunic::vTransCaratere(UC)
                                        0      0     20
     CLCommunic::~CLCommunic()          2      0      8
       -> operator delete(void *)       4      0      0


   Segment part sizes:

     Function/Label                      Bytes
     --------------                      -----
     _A_IE                                  1
     SBUF                                   1
     _A_SCON                                1
     _A_PCON                                1
     _A_TCON                                1
     TH1                                    1
     _A_TMOD                                1
     CLCommunic::ucEtatTrame                1
     CLCommunic::ucNbCaractRecu             1
     CLCommunic::ucLongueurTrame            1
     CLCommunic::ucLongueurTampon           1
     CLCommunic::ucCaractereRecu            1
     CLCommunic::ucEtatReception            1
     CLCommunic::cpDebutTrame               2
     CLCommunic::cpFinTrame                 2
     CLCommunic::cptrEcriture               2
     CLCommunic::cptrLecture                2
     CLCommunic::cTabCaractereRecu          2
     CLCommunic::CLCommunic()             124
     CLCommunic::CLCommunic(UC, UC, UI)
                                          160
     CLCommunic::~CLCommunic()             42
     CLCommunic::ucInitLongTrame(UC)
                                           44
     CLCommunic::ucValideTrame()           65
     CLCommunic::vTransCaratere(UC)         9
     CLCommunic::vAffChaine(char const *)
                                           33
     CLCommunic::ucLireNbCaractRecu()
                                           14
     CLCommunic::ucLireEtatTrame()         14
     CLCommunic::ucpLireTrame()            37
     CLCommunic::vInitBaudRate(UI)         74
     CLCommunic::vInteruptSerial()        204
     CLCommunic::vTransChiffre(UI)        211
     CLCommunic::ucLireTrameSansCheck()
                                           20
     CLCommunic::ucLireEtatReception()
                                           14
     ??vInteruptSerial??INTVEC 35           3
     ?<Initializer for ucLongueurTrame>     1
     ?<Initializer for ucLongueurTampon>    1
     CLCommunic::new CLCommunic()          49
     CLCommunic::new CLCommunic(UC, UC, UI)
                                           72
     CLCommunic::delete ~CLCommunic(CLCommunic *)
                                           32

 
     3 bytes in segment INTVEC
 1 218 bytes in segment NEAR_CODE
     7 bytes in segment SFR_AN
     2 bytes in segment XDATA_I
     2 bytes in segment XDATA_ID
    14 bytes in segment XDATA_Z
 
 1 220 bytes of CODE  memory (+ 3 bytes shared)
     0 bytes of DATA  memory (+ 7 bytes shared)
    16 bytes of XDATA memory

Errors: none
Warnings: none
