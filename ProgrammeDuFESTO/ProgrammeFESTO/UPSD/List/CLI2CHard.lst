###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.1.40194/W32 for 8051         24/Nov/2014  22:54:32 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  near                                               #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Synchro\Dropbox\Travaux\Automne                 #
#                          2014\ProjetSession5\ProgrammeDuFESTO\ProgrammeFEST #
#                          O\CLI2CHard.cpp                                    #
#    Command line       =  "C:\Synchro\Dropbox\Travaux\Automne                #
#                          2014\ProjetSession5\ProgrammeDuFESTO\ProgrammeFEST #
#                          O\CLI2CHard.cpp" -D UPSD3254A --preprocess=cl      #
#                          "C:\Synchro\Dropbox\Travaux\Automne                #
#                          2014\ProjetSession5\ProgrammeDuFESTO\ProgrammeFEST #
#                          O\UPSD\List\" -lC "C:\Synchro\Dropbox\Travaux\Auto #
#                          mne 2014\ProjetSession5\ProgrammeDuFESTO\Programme #
#                          FESTO\UPSD\List\" -lA "C:\Synchro\Dropbox\Travaux\ #
#                          Automne 2014\ProjetSession5\ProgrammeDuFESTO\Progr #
#                          ammeFESTO\UPSD\List\" -o                           #
#                          "C:\Synchro\Dropbox\Travaux\Automne                #
#                          2014\ProjetSession5\ProgrammeDuFESTO\ProgrammeFEST #
#                          O\UPSD\Obj\" -e --no_cse --no_unroll --no_inline   #
#                          --no_code_motion --no_tbaa --debug --core=plain    #
#                          --dptr=16,1 --data_model=large --code_model=near   #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data --nr_virtual_regs 8         #
#                          --dlib_config "C:\Program Files (x86)\IAR          #
#                          Systems\Embedded Workbench                         #
#                          6.0\8051\LIB\DLIB\dl8051Normal.h" -Ol --eec++      #
#    List file          =  C:\Synchro\Dropbox\Travaux\Automne                 #
#                          2014\ProjetSession5\ProgrammeDuFESTO\ProgrammeFEST #
#                          O\UPSD\List\CLI2CHard.lst                          #
#    Object file        =  C:\Synchro\Dropbox\Travaux\Automne                 #
#                          2014\ProjetSession5\ProgrammeDuFESTO\ProgrammeFEST #
#                          O\UPSD\Obj\CLI2CHard.r51                           #
#                                                                             #
#                                                                             #
###############################################################################

C:\Synchro\Dropbox\Travaux\Automne 2014\ProjetSession5\ProgrammeDuFESTO\ProgrammeFESTO\CLI2CHard.cpp
      1          // ************************** FICHIER: CLI2CHARD.cpp****************************
      2          //
      3          // Fonctions de communication de base en I2C
      4          //
      5          // Application realisee avec IAR C++ 8.10
      6          //
      7          // AUTEUR : VINCENT CHOUINARD
      8          // DATE CREATION : 2014/08/9 VERSION: 1.0
      9          // DATE MODIFICATION: ****-**-**
     10          //
     11          // *****************************************************************************
     12          #include "CLI2CHard.h"               //

   \                                 In  segment SFR_AN, at 0xa7
   \   union <unnamed> volatile __sfr _A_IEA
   \                     _A_IEA:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb7
   \   union <unnamed> volatile __sfr _A_IPA
   \                     _A_IPA:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xdd
   \   union <unnamed> volatile __sfr _A_S2STA
   \                     _A_S2STA:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xdc
   \   union <unnamed> volatile __sfr _A_S2CON
   \                     _A_S2CON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x93
   \   union <unnamed> volatile __sfr _A_P3SFS
   \                     _A_P3SFS:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xde
   \   unsigned char volatile __sfr S2DAT
   \                     S2DAT:
   \   000000                DS 1
     13          #include "_DeclarationGenerale.h"    //
     14          #include "ConversionKeilToIAR.h"     // Conversion KEIL <--> IAR
     15          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     16          bool CLI2CHARD :: bus_lost_flag;     //
   \                     ??bus_lost_flag:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     17          bool CLI2CHARD :: i2cwait;           // Pour controler le delais
   \                     ??i2cwait:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     18          bool CLI2CHARD :: i2c_master;        //
   \                     ??i2c_master:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     19          bool CLI2CHARD :: i2c_xmitr;         //
   \                     ??i2c_xmitr:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     20          bool CLI2CHARD :: slave_nack_flag;   //
   \                     ??slave_nack_flag:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     21          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     22          UI   CLI2CHARD :: i;                 // array pointer
   \                     ??i:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     23          UC   CLI2CHARD :: i2c_xmit_buf[256]; // message transmission buffer
   \                     ??i2c_xmit_buf:
   \   000000                DS 256
   \   000100                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     24          UC   CLI2CHARD :: i2c_rcv_buf [256]; // message reception buffer
   \                     ??i2c_rcv_buf:
   \   000000                DS 256
   \   000100                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     25          UC   CLI2CHARD :: dummybyte;
   \                     ??dummybyte:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     26          UC   CLI2CHARD :: i2c_timeout;       // dummy byte to rcv, timeout cz
   \                     ??i2c_timeout:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     27          
     28          // *****************************************************************************
     29          //                            LE CONSTRUCTEUR initialisateur
     30          // *****************************************************************************

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
     31          CLI2CHARD :: CLI2CHARD(void)
   \                     ??CLI2CHARD:
     32          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
     33          vInitUpsd(); // Initialise les SFR du bus I2C du uPSD3254
   \   000008                ; Setup parameters for call to function CLI2CHARD::vInitUpsd()
   \   000008   AA82         MOV     R2,DPL
   \   00000A   AB83         MOV     R3,DPH
   \   00000C   12....       LCALL   ??vInitUpsd
     34          }
   \   00000F   AA82         MOV     R2,DPL
   \   000011   AB83         MOV     R3,DPH
   \   000013   D083         POP     DPH
   \   000015   D082         POP     DPL
   \   000017   22           RET
     35          
     36          // *****************************************************************************
     37          //                            LE DESTRUCTEUR
     38          // *****************************************************************************

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
     39          CLI2CHARD :: ~CLI2CHARD(void)
   \                     `?~CLI2CHARD`:
     40          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     41          
     42          }
   \   000000   22           RET
     43          
     44          // **********************FONCTION: vInitUpsd()**********************************
     45          //
     46          // DESCRIPTION: Initialise les registres du bus I2C hardware du uPSD
     47          //
     48          // INCLUDE: "_DeclarationGenerale.h"
     49          //          "CLI2CHard.h"
     50          //
     51          // PROTOTYPE:           void vInitUpsd(void)
     52          //
     53          // PROCEDURE D'APPEL:   vInitUpsd()
     54          //
     55          // PARAMETRE D'ENTREE:  AUCUN
     56          //
     57          // PARAMETRE DE SORTIE: AUCUN
     58          //
     59          // EXEMPLE: vInitUpsd() ---> Initialise le bus I2C Hardware
     60          //
     61          // Auteur:              Vincent Chouinard
     62          // Date:                16 septembre 2014   (Version 1.0)
     63          // Modification:
     64          // *****************************************************************************

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
     65          void CLI2CHARD :: vInitUpsd(void)
   \                     ??vInitUpsd:
     66          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
     67          P3SFS           |= 0xC0;  // Enable P3.7 for SCL, P3.6 for SDA
   \   000004   4393C0       ORL     0x93,#0xc0
     68          S2CON           |= 0x01;  // Setup I2C-2 for 500KHz (24MHz XTAL)
   \   000007   43DC01       ORL     0xdc,#0x1
     69          i2c_init_flag    = 1;     // set init done flag
   \   00000A   7401         MOV     A,#0x1
   \   00000C   8A82         MOV     DPL,R2
   \   00000E   8B83         MOV     DPH,R3
   \   000010   F0           MOVX    @DPTR,A
     70          i2c_timeout_flag = 0;     // clear timeout error flag
   \   000011   7400         MOV     A,#0x0
   \   000013   8A82         MOV     DPL,R2
   \   000015   8B83         MOV     DPH,R3
   \   000017   A3           INC     DPTR
   \   000018   F0           MOVX    @DPTR,A
     71          i2cwait          = 0;     // Petit delais d'attente
   \   000019   7400         MOV     A,#0x0
   \   00001B   90....       MOV     DPTR,#??i2cwait
   \   00001E   F0           MOVX    @DPTR,A
     72          IPA             |= 0x02;  // set high priority for EI2C
   \   00001F   43B702       ORL     0xb7,#0x2
     73          IEA             |= 0x02;  // set EI2C I2C Int. Enable bit
   \   000022   43A702       ORL     0xa7,#0x2
     74          }
   \   000025   D083         POP     DPH
   \   000027   D082         POP     DPL
   \   000029   22           RET
   \   00002A                REQUIRE _A_P3SFS
   \   00002A                REQUIRE _A_S2CON
   \   00002A                REQUIRE _A_IPA
   \   00002A                REQUIRE _A_IEA
     75          
     76          // **********************FONCTION: vI2C_WaitInterrupt()*************************
     77          //
     78          // DESCRIPTION: Permet d'attendre qu'un interrupt survient
     79          //
     80          // INCLUDE: "_DeclarationGenerale.h"
     81          //          "CLI2CHard.h"
     82          //
     83          // PROTOTYPE:           void vI2C_WaitInterrupt(void)
     84          //
     85          // PROCEDURE D'APPEL:   vI2C_WaitInterrupt()
     86          //
     87          // PARAMETRE D'ENTREE:  AUCUN
     88          //
     89          // PARAMETRE DE SORTIE: AUCUN
     90          //
     91          // EXEMPLE: vI2C_WaitInterrupt() ---> Attend un interrupt
     92          //
     93          // Auteur:              Vincent Chouinard
     94          // Date:                16 septembre 2014   (Version 1.0)
     95          // Modification:
     96          // *****************************************************************************

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
     97          void CLI2CHARD :: vI2C_WaitInterrupt(void)
   \                     ??vI2C_WaitInterrupt:
     98          {
   \   000000   74F8         MOV     A,#-0x8
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 8
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
     99          i2cwait     = 1;            // Flag d'attente
   \   000009   7401         MOV     A,#0x1
   \   00000B   90....       MOV     DPTR,#??i2cwait
   \   00000E   F0           MOVX    @DPTR,A
    100          i2c_timeout = 0;            // Flag de depassement d'attente
   \   00000F   90....       MOV     DPTR,#??i2c_timeout
   \   000012   7400         MOV     A,#0x0
   \   000014   F0           MOVX    @DPTR,A
   \   000015   802D         SJMP    ??vI2C_WaitInterrupt_1
    101          
    102          while (i2cwait == 1)        // Wait for int to clear flag
    103            {                         //
    104             if(i2c_timeout >= 2 )    // XmS timeout loop
   \                     ??vI2C_WaitInterrupt_2:
   \   000017   90....       MOV     DPTR,#??i2c_timeout
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   C3           CLR     C
   \   00001C   9402         SUBB    A,#0x2
   \   00001E   400E         JC      ??vI2C_WaitInterrupt_3
    105               {                      //
    106                i2c_timeout_flag = 1; // set error flag
   \   000020   7401         MOV     A,#0x1
   \   000022   8E82         MOV     DPL,R6
   \   000024   8F83         MOV     DPH,R7
   \   000026   A3           INC     DPTR
   \   000027   F0           MOVX    @DPTR,A
    107                i2cwait          = 0; // Reset le flag d'attente
   \   000028   7400         MOV     A,#0x0
   \   00002A   90....       MOV     DPTR,#??i2cwait
   \   00002D   F0           MOVX    @DPTR,A
    108               }                      //
    109             vDelay(i);               // 1 mS delay (approximatively)
   \                     ??vI2C_WaitInterrupt_3:
   \   00002E                ; Setup parameters for call to function CLI2CHARD::vDelay(UINT16)
   \   00002E   90....       MOV     DPTR,#??i
   \   000031   E0           MOVX    A,@DPTR
   \   000032   FC           MOV     R4,A
   \   000033   A3           INC     DPTR
   \   000034   E0           MOVX    A,@DPTR
   \   000035   FD           MOV     R5,A
   \   000036   EE           MOV     A,R6
   \   000037   FA           MOV     R2,A
   \   000038   EF           MOV     A,R7
   \   000039   FB           MOV     R3,A
   \   00003A   12....       LCALL   ??vDelay
    110             i2c_timeout++;           // for the timeloop
   \   00003D   90....       MOV     DPTR,#??i2c_timeout
   \   000040   E0           MOVX    A,@DPTR
   \   000041   2401         ADD     A,#0x1
   \   000043   F0           MOVX    @DPTR,A
    111            }
   \                     ??vI2C_WaitInterrupt_1:
   \   000044   90....       MOV     DPTR,#??i2cwait
   \   000047   E0           MOVX    A,@DPTR
   \   000048   70CD         JNZ     ??vI2C_WaitInterrupt_2
    112          }
   \   00004A   7F01         MOV     R7,#0x1
   \   00004C   02....       LJMP    ?FUNC_LEAVE_XDATA
    113          
    114          // **********************FONCTION: vIntrI2C()***********************************
    115          //
    116          // DESCRIPTION: Fonction PRAGMA VECTOR d'interruption
    117          //
    118          // INCLUDE: "_DeclarationGenerale.h"
    119          //          "CLI2CHard.h"
    120          //
    121          // PROTOTYPE:            #pragma vector = 0x43 __interrupt void CLI2CHARD :: vIntrI2C(void)
    122          //
    123          // PROCEDURE D'APPEL:   Purement hardware
    124          //
    125          // PARAMETRE D'ENTREE:  AUCUN
    126          //
    127          // PARAMETRE DE SORTIE: AUCUN
    128          //
    129          // EXEMPLE: Survient lors d'une interruption sur le vecteur 0x43
    130          //
    131          // Auteur:              Vincent Chouinard
    132          // Date:                16 septembre 2014   (Version 1.0)
    133          // Modification:
    134          // *****************************************************************************
    135           #pragma vector = 0x43                       // Lors d'une interruption de type INTERRUPT I2C

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    136          __interrupt void CLI2CHARD :: vIntrI2C(void) // I2C Hardware interrupt
   \                     ??vIntrI2C:
    137          {
   \   000000   C0E0         PUSH    A
   \   000002   C0D0         PUSH    PSW
   \   000004   E8           MOV     A,R0
   \   000005   C0E0         PUSH    A
   \   000007   E9           MOV     A,R1
   \   000008   C0E0         PUSH    A
   \   00000A   C082         PUSH    DPL
   \   00000C   C083         PUSH    DPH
   \   00000E                ; Saved register size: 6
   \   00000E                ; Auto size: 0
    138          if((S2STA & BLOST) == 1)    // If I2C bus is out of sync
                 ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \   00000E   E5DD         MOV     A,0xdd
   \   000010   F8           MOV     R0,A
   \   000011   E5DD         MOV     A,0xdd
   \   000013   F9           MOV     R1,A
   \   000014   E8           MOV     A,R0
   \   000015   A2E0         MOV     C,0xE0 /* A   */.0
   \   000017   500E         JNC     ??vIntrI2C_1
   \   000019   E9           MOV     A,R1
   \   00001A   A2E2         MOV     C,0xE0 /* A   */.2
   \   00001C   5009         JNC     ??vIntrI2C_1
    139            {
    140             S2DAT = dummy;           // send dummy byte
   \   00001E   75DEFF       MOV     0xde,#-0x1
    141             bus_lost_flag    = 1;    // Activate bus loss flag
   \   000021   7401         MOV     A,#0x1
   \   000023   90....       MOV     DPTR,#??bus_lost_flag
   \   000026   F0           MOVX    @DPTR,A
    142            }
    143          
    144          if((S2STA & ACKR)  == 1)    // If bus send nACK
                 ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \                     ??vIntrI2C_1:
   \   000027   E5DD         MOV     A,0xdd
   \   000029   F8           MOV     R0,A
   \   00002A   E5DD         MOV     A,0xdd
   \   00002C   F9           MOV     R1,A
   \   00002D   E8           MOV     A,R0
   \   00002E   A2E0         MOV     C,0xE0 /* A   */.0
   \   000030   500E         JNC     ??vIntrI2C_2
   \   000032   E9           MOV     A,R1
   \   000033   A2E1         MOV     C,0xE0 /* A   */.1
   \   000035   5009         JNC     ??vIntrI2C_2
    145            {
    146             S2DAT = dummy;           // send dummy byte
   \   000037   75DEFF       MOV     0xde,#-0x1
    147             slave_nack_flag  = 1;    // Activate bus loss flag
   \   00003A   7401         MOV     A,#0x1
   \   00003C   90....       MOV     DPTR,#??slave_nack_flag
   \   00003F   F0           MOVX    @DPTR,A
    148            }
    149           
    150          if(i2c_master & i2c_xmitr)  // If master must transmit
   \                     ??vIntrI2C_2:
   \   000040   90....       MOV     DPTR,#??i2c_xmitr
   \   000043   E0           MOVX    A,@DPTR
   \   000044   C0E0         PUSH    A
   \   000046   90....       MOV     DPTR,#??i2c_master
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   F8           MOV     R0,A
   \   00004B   D0E0         POP     A
   \   00004D   58           ANL     A,R0
   \   00004E   6006         JZ      ??vIntrI2C_3
    151            {                         // Master transmitter mode
    152             i2cwait = 0;             // reset wait flag
   \   000050   7400         MOV     A,#0x0
   \   000052   90....       MOV     DPTR,#??i2cwait
   \   000055   F0           MOVX    @DPTR,A
    153            }
    154          
    155          if(i2c_master & ~i2c_xmitr) // If master must receive
   \                     ??vIntrI2C_3:
   \   000056   90....       MOV     DPTR,#??i2c_xmitr
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   A2E0         MOV     C,0xE0 /* A   */.0
   \   00005C   B3           CPL     C
   \   00005D   E4           CLR     A
   \   00005E   33           RLC     A
   \   00005F   C0E0         PUSH    A
   \   000061   90....       MOV     DPTR,#??i2c_master
   \   000064   E0           MOVX    A,@DPTR
   \   000065   F8           MOV     R0,A
   \   000066   D0E0         POP     A
   \   000068   58           ANL     A,R0
   \   000069   6006         JZ      ??vIntrI2C_4
    156            {                         // Master receiver mode
    157             i2cwait = 0;             // reset wait flag
   \   00006B   7400         MOV     A,#0x0
   \   00006D   90....       MOV     DPTR,#??i2cwait
   \   000070   F0           MOVX    @DPTR,A
    158            }
    159          }
   \                     ??vIntrI2C_4:
   \   000071   D083         POP     DPH
   \   000073   D082         POP     DPL
   \   000075   D0E0         POP     A
   \   000077   F9           MOV     R1,A
   \   000078   D0E0         POP     A
   \   00007A   F8           MOV     R0,A
   \   00007B   D0D0         POP     PSW
   \   00007D   D0E0         POP     A
   \   00007F   32           RETI
   \   000080                REQUIRE _A_S2STA
   \   000080                REQUIRE S2DAT
    160          
    161          // **********************FONCTION: vEcritOctet()*************************
    162          //
    163          // DESCRIPTION: Permet d'attendre qu'un interrupt survient
    164          //
    165          // INCLUDE: "_DeclarationGenerale.h"
    166          //          "CLI2CHard.h"
    167          //
    168          // PROTOTYPE:           void vEcritOctet(UC, UC)
    169          //
    170          // PROCEDURE D'APPEL:   vEcritOctet(UC ucAdresse, UC ucData)
    171          //
    172          // PARAMETRE D'ENTREE:  ucAdresse et ucData
    173          //
    174          // PARAMETRE DE SORTIE: AUCUN
    175          //
    176          // EXEMPLE: vEcritOctet(0x43, 0x8A) ---> Ecrit 8A sur un chip dont l'adresse est 0x43
    177          //
    178          // Auteur:              Vincent Chouinard
    179          // Date:                16 septembre 2014   (Version 1.0)
    180          // Modification:
    181          // *****************************************************************************

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    182          void CLI2CHARD :: vEcritOctet(UC ucAdresse, UC ucData)
   \                     ??vEcritOctet:
    183          {
   \   000000   74F8         MOV     A,#-0x8
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 8
   \   000005                ; Auto size: 0
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   E9           MOV     A,R1
   \   00000A   FE           MOV     R6,A
   \   00000B   EC           MOV     A,R4
   \   00000C   FF           MOV     R7,A
    184          EN1 = 1;                    // Enable I2C.
   \   00000D   43DC40       ORL     0xdc,#0x40
    185          STA = 1;                    // Send start bit
   \   000010   43DC20       ORL     0xdc,#0x20
    186          S2DAT = ucAdresse /*& 0xFE*/;   // Envoyer adresse I2C du dispositif
   \   000013   8EDE         MOV     0xde,R6
    187          vI2C_WaitInterrupt();       // Wait for interrupt
   \   000015                ; Setup parameters for call to function CLI2CHARD::vI2C_WaitInterrupt()
   \   000015   AA82         MOV     R2,DPL
   \   000017   AB83         MOV     R3,DPH
   \   000019   12....       LCALL   ??vI2C_WaitInterrupt
    188          AA    = 1;                  // Send ACKowledge
   \   00001C   43DC04       ORL     0xdc,#0x4
    189          STA   = 0;                  // Clear STA (Disable START)
   \   00001F   53DCDF       ANL     0xdc,#0xdf
    190          
    191          // ********************************************************
    192          // CE QUI EST IMPORTANT C'EST DE METTRE LE STOP AVANT
    193          // LA DERNIERE INTERRUPTION SOIT LA TRANSMISSION DU DERNIER
    194          // OCTET.
    195          // ********************************************************
    196          STO   = 1;                  // Send STOP bit
   \   000022   43DC10       ORL     0xdc,#0x10
    197          S2DAT = ucData;             // Envoyer la donnee ucData
   \   000025   8FDE         MOV     0xde,R7
    198          vI2C_WaitInterrupt();       // Wait for interrupt.
   \   000027                ; Setup parameters for call to function CLI2CHARD::vI2C_WaitInterrupt()
   \   000027   AA82         MOV     R2,DPL
   \   000029   AB83         MOV     R3,DPH
   \   00002B   12....       LCALL   ??vI2C_WaitInterrupt
    199          STA   = 0;                  // Disable START).
   \   00002E   53DCDF       ANL     0xdc,#0xdf
    200          STO   = 0;                  // Send STOP bit).
   \   000031   53DCEF       ANL     0xdc,#0xef
    201          EN1   = 0;                  // Disiable I2C-2
   \   000034   53DCBF       ANL     0xdc,#0xbf
    202          }
   \   000037   7F01         MOV     R7,#0x1
   \   000039   02....       LJMP    ?FUNC_LEAVE_XDATA
   \   00003C                REQUIRE _A_S2CON
   \   00003C                REQUIRE S2DAT
    203          
    204          // **********************FONCTION: ucLitOctet()*************************
    205          //
    206          // DESCRIPTION: Permet d'attendre qu'un interrupt survient
    207          //
    208          // INCLUDE: "_DeclarationGenerale.h"
    209          //          "CLI2CHard.h"
    210          //
    211          // PROTOTYPE:           UC ucLitOctet(UC)
    212          //
    213          // PROCEDURE D'APPEL:   UC = ucLitOctet(UC ucAdresse)
    214          //
    215          // PARAMETRE D'ENTREE:  ucAdresse
    216          //
    217          // PARAMETRE DE SORTIE: ucData
    218          //
    219          // EXEMPLE: UC = ucLitOctet(0x43) ---> Lit la data sur un chip dont l'adresse est 0x43
    220          //
    221          // Auteur:              Vincent Chouinard
    222          // Date:                16 septembre 2014   (Version 1.0)
    223          // Modification:
    224          // *****************************************************************************

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    225          UC CLI2CHARD :: ucLitOctet(UC ucAdresse)
   \                     ??ucLitOctet:
    226          {
   \   000000   74F8         MOV     A,#-0x8
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 8
   \   000005                ; Auto size: 0
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   E9           MOV     A,R1
   \   00000A   FF           MOV     R7,A
    227          UC ucData;                  // Pour enregistrer la donnee lue
    228          EN1 = 1;                    // Enable I2C.
   \   00000B   43DC40       ORL     0xdc,#0x40
    229          STA = 1;                    // Set STA to send start bit).
   \   00000E   43DC20       ORL     0xdc,#0x20
    230          
    231                                      // Envoyer adresse du dispositif en lecture.
    232                                      // Masquer pour s'assurer d'une adresse de lecture.
    233          S2DAT = (ucAdresse | 0x01); // I2C addresse en lecture (R/W bit)
   \   000011   7401         MOV     A,#0x1
   \   000013   4F           ORL     A,R7
   \   000014   F5DE         MOV     0xde,A
    234          vI2C_WaitInterrupt();       // Wait for interrupt
   \   000016                ; Setup parameters for call to function CLI2CHARD::vI2C_WaitInterrupt()
   \   000016   AA82         MOV     R2,DPL
   \   000018   AB83         MOV     R3,DPH
   \   00001A   12....       LCALL   ??vI2C_WaitInterrupt
    235          
    236          AA  = 1;                    // Send ACKowledge
   \   00001D   43DC04       ORL     0xdc,#0x4
    237          STA = 0;                    // Disable START
   \   000020   53DCDF       ANL     0xdc,#0xdf
    238          STO = 0;                    // Send STOP bit
   \   000023   53DCEF       ANL     0xdc,#0xef
    239          
    240                                      // Important de conserver les 2 lignes suivantes
    241                                      // pour mettre le I2C en entree.
    242          S2DAT = 0xFF;               // Send byte for rcv mode.
   \   000026   75DEFF       MOV     0xde,#-0x1
    243          vI2C_WaitInterrupt();       // Wait for interrupt
   \   000029                ; Setup parameters for call to function CLI2CHARD::vI2C_WaitInterrupt()
   \   000029   AA82         MOV     R2,DPL
   \   00002B   AB83         MOV     R3,DPH
   \   00002D   12....       LCALL   ??vI2C_WaitInterrupt
    244          
    245          // ********************************************************
    246          // CE QUI EST IMPORTANT C'EST DE METTRE LE STOP AVANT
    247          // LA DERNIERE INTERRUPTION SOIT LA RECEPTION DU DERNIER
    248          // OCTET.
    249          // ********************************************************
    250          STO    = 1;                 // Send STOP bit
   \   000030   43DC10       ORL     0xdc,#0x10
    251          ucData = S2DAT;             // Lire dernier octet.
   \   000033   E5DE         MOV     A,0xde
   \   000035   FE           MOV     R6,A
    252          vI2C_WaitInterrupt();       // Wait for interrupt
   \   000036                ; Setup parameters for call to function CLI2CHARD::vI2C_WaitInterrupt()
   \   000036   AA82         MOV     R2,DPL
   \   000038   AB83         MOV     R3,DPH
   \   00003A   12....       LCALL   ??vI2C_WaitInterrupt
    253          AA     = 0;                 // Send Not ACKnowledge
   \   00003D   53DCFB       ANL     0xdc,#0xfb
    254          STA    = 0;                 // Disable START
   \   000040   53DCDF       ANL     0xdc,#0xdf
    255          EN1    = 0;                 // Disiable I2C-2
   \   000043   53DCBF       ANL     0xdc,#0xbf
    256          return(ucData);
   \   000046   EE           MOV     A,R6
   \   000047   F9           MOV     R1,A
   \   000048   7F01         MOV     R7,#0x1
   \   00004A   02....       LJMP    ?FUNC_LEAVE_XDATA
   \   00004D                REQUIRE _A_S2CON
   \   00004D                REQUIRE S2DAT
    257          }
    258          
    259          
    260          // **********************FONCTION: vDelay()*************************
    261          //
    262          // DESCRIPTION: Permet d'attendre qu'un interrupt survient
    263          //
    264          // INCLUDE: "_DeclarationGenerale.h"
    265          //          "CLI2CHard.h"
    266          //
    267          // PROTOTYPE:           void vDelay(UINT16)
    268          //
    269          // PROCEDURE D'APPEL:   vDelay(UINT16)
    270          //
    271          // PARAMETRE D'ENTREE:  vDelay
    272          //
    273          // PARAMETRE DE SORTIE: AUCUN
    274          //
    275          // EXEMPLE: vDelay(555) ---> Cre un delais de 555 unite de temps
    276          //
    277          // Auteur:              Vincent Chouinard
    278          // Date:                16 septembre 2014   (Version 1.0)
    279          // Modification:
    280          // *****************************************************************************

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    281          void CLI2CHARD :: vDelay(UINT16 iWasteMyTime)
   \                     ??vDelay:
    282          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    283          for(iWasteMyTime = 0; iWasteMyTime < 10; iWasteMyTime++)
   \   000000   7800         MOV     R0,#0x0
   \   000002   7900         MOV     R1,#0x0
   \   000004   8008         SJMP    ??vDelay_1
   \                     ??vDelay_2:
   \   000006   E8           MOV     A,R0
   \   000007   2401         ADD     A,#0x1
   \   000009   F8           MOV     R0,A
   \   00000A   E9           MOV     A,R1
   \   00000B   3400         ADDC    A,#0x0
   \   00000D   F9           MOV     R1,A
   \                     ??vDelay_1:
   \   00000E   C3           CLR     C
   \   00000F   E8           MOV     A,R0
   \   000010   940A         SUBB    A,#0xa
   \   000012   E9           MOV     A,R1
   \   000013   9400         SUBB    A,#0x0
   \   000015   40EF         JC      ??vDelay_2
    284            {
    285              /*Perd du temps dans une boucle FOR*/
    286            }
    287          }
   \   000017   22           RET

   \                                 In  segment INTVEC, offset 0x43, root
   \                     `??vIntrI2C??INTVEC 67`:
   \   000043   02....       LJMP       (??vIntrI2C)

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \   __near_func __xdata_reentrant CLI2CHARD &CLI2CHARD::new CLI2CHARD()
   \                     `??new CLI2CHARD`:
   \   000000   C0..         PUSH    ?V0 + 0
   \   000002   C0..         PUSH    ?V0 + 1
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004                ; Setup parameters for call to function operator new(unsigned int)
   \   000004   7A02         MOV     R2,#0x2
   \   000006   7B00         MOV     R3,#0x0
   \   000008   12....       LCALL   `??operator new`
   \   00000B   8A..         MOV     ?V0 + 0,R2
   \   00000D   8B..         MOV     ?V0 + 1,R3
   \   00000F   A8..         MOV     R0,?V0 + 0
   \   000011   A9..         MOV     R1,?V0 + 1
   \   000013   E8           MOV     A,R0
   \   000014   FA           MOV     R2,A
   \   000015   E9           MOV     A,R1
   \   000016   FB           MOV     R3,A
   \   000017   E8           MOV     A,R0
   \   000018   49           ORL     A,R1
   \   000019   600D         JZ      `??new CLI2CHARD_1`
   \   00001B                ; Setup parameters for call to function CLI2CHARD::CLI2CHARD()
   \   00001B   12....       LCALL   ??CLI2CHARD
   \   00001E   8A..         MOV     ?V0 + 0,R2
   \   000020   8B..         MOV     ?V0 + 1,R3
   \   000022   AA..         MOV     R2,?V0 + 0
   \   000024   AB..         MOV     R3,?V0 + 1
   \   000026   8004         SJMP    `??new CLI2CHARD_2`
   \                     `??new CLI2CHARD_1`:
   \   000028   7A00         MOV     R2,#0x0
   \   00002A   7B00         MOV     R3,#0x0
   \                     `??new CLI2CHARD_2`:
   \   00002C   D0..         POP     ?V0 + 1
   \   00002E   D0..         POP     ?V0 + 0
   \   000030   22           RET

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \   __near_func __xdata_reentrant void CLI2CHARD::delete ~CLI2CHARD(CLI2CHARD *)
   \                     `??delete ~CLI2CHARD`:
   \   000000   74F8         MOV     A,#-0x8
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 8
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   EE           MOV     A,R6
   \   00000A   4F           ORL     A,R7
   \   00000B   600E         JZ      `??delete ~CLI2CHARD_1`
   \   00000D                ; Setup parameters for call to function CLI2CHARD::~CLI2CHARD()
   \   00000D   EE           MOV     A,R6
   \   00000E   FA           MOV     R2,A
   \   00000F   EF           MOV     A,R7
   \   000010   FB           MOV     R3,A
   \   000011   12....       LCALL   `?~CLI2CHARD`
   \   000014                ; Setup parameters for call to function operator delete(void *)
   \   000014   EE           MOV     A,R6
   \   000015   FA           MOV     R2,A
   \   000016   EF           MOV     A,R7
   \   000017   FB           MOV     R3,A
   \   000018   12....       LCALL   `??operator delete`
   \                     `??delete ~CLI2CHARD_1`:
   \   00001B   7F01         MOV     R7,#0x1
   \   00001D   02....       LJMP    ?FUNC_LEAVE_XDATA
    288          //LinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxTUX

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     CLI2CHARD::CLI2CHARD()             2      0      0
       -> CLI2CHARD::vInitUpsd()        4      0      0
     CLI2CHARD::delete ~CLI2CHARD(CLI2CHARD *)
                                        0      0      8
       -> CLI2CHARD::~CLI2CHARD()       0      0     16
       -> operator delete(void *)       0      0     16
     CLI2CHARD::new CLI2CHARD()         2      0      0
       -> operator new(unsigned int)
                                        4      0      0
       -> CLI2CHARD::CLI2CHARD()        4      0      0
     CLI2CHARD::ucLitOctet(UC)          0      0      8
       -> CLI2CHARD::vI2C_WaitInterrupt()
                                        0      0     16
       -> CLI2CHARD::vI2C_WaitInterrupt()
                                        0      0     16
       -> CLI2CHARD::vI2C_WaitInterrupt()
                                        0      0     16
     CLI2CHARD::vDelay(UINT16)          0      0      8
     CLI2CHARD::vEcritOctet(UC, UC)     0      0      8
       -> CLI2CHARD::vI2C_WaitInterrupt()
                                        0      0     16
       -> CLI2CHARD::vI2C_WaitInterrupt()
                                        0      0     16
     CLI2CHARD::vI2C_WaitInterrupt()
                                        1      0     16
       -> CLI2CHARD::vDelay(UINT16)     0      0     16
     CLI2CHARD::vInitUpsd()             3      0      0
     CLI2CHARD::vIntrI2C()              7      0      0
     CLI2CHARD::~CLI2CHARD()            0      0      8


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     _A_IEA                            1
     _A_IPA                            1
     _A_S2STA                          1
     _A_S2CON                          1
     _A_P3SFS                          1
     S2DAT                             1
     CLI2CHARD::bus_lost_flag          1
     CLI2CHARD::i2cwait                1
     CLI2CHARD::i2c_master             1
     CLI2CHARD::i2c_xmitr              1
     CLI2CHARD::slave_nack_flag        1
     CLI2CHARD::i                      2
     CLI2CHARD::i2c_xmit_buf         256
     CLI2CHARD::i2c_rcv_buf          256
     CLI2CHARD::dummybyte              1
     CLI2CHARD::i2c_timeout            1
     CLI2CHARD::CLI2CHARD()           24
     CLI2CHARD::~CLI2CHARD()           1
     CLI2CHARD::vInitUpsd()           42
     CLI2CHARD::vI2C_WaitInterrupt()
                                      79
     CLI2CHARD::vIntrI2C()           128
     CLI2CHARD::vEcritOctet(UC, UC)   60
     CLI2CHARD::ucLitOctet(UC)        77
     CLI2CHARD::vDelay(UINT16)        24
     ??vIntrI2C??INTVEC 67             3
     CLI2CHARD::new CLI2CHARD()       49
     CLI2CHARD::delete ~CLI2CHARD(CLI2CHARD *)
                                      32

 
   3 bytes in segment INTVEC
 516 bytes in segment NEAR_CODE
   6 bytes in segment SFR_AN
 521 bytes in segment XDATA_Z
 
 516 bytes of CODE  memory (+ 3 bytes shared)
   0 bytes of DATA  memory (+ 6 bytes shared)
 521 bytes of XDATA memory

Errors: none
Warnings: 2
