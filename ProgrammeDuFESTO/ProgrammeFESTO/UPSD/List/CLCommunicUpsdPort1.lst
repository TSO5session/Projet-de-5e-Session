###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.1.40194/W32 for 8051         28/Nov/2014  08:11:50 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  near                                               #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Synchro\Dropbox\Travaux\Automne                 #
#                          2014\ProjetSession5\ProgrammeDuFESTO\ProgrammeFEST #
#                          O\CLCommunicUpsdPort1.cpp                          #
#    Command line       =  "C:\Synchro\Dropbox\Travaux\Automne                #
#                          2014\ProjetSession5\ProgrammeDuFESTO\ProgrammeFEST #
#                          O\CLCommunicUpsdPort1.cpp" -D UPSD3254A            #
#                          --preprocess=cl "C:\Synchro\Dropbox\Travaux\Automn #
#                          e 2014\ProjetSession5\ProgrammeDuFESTO\ProgrammeFE #
#                          STO\UPSD\List\" -lC "C:\Synchro\Dropbox\Travaux\Au #
#                          tomne 2014\ProjetSession5\ProgrammeDuFESTO\Program #
#                          meFESTO\UPSD\List\" -lA "C:\Synchro\Dropbox\Travau #
#                          x\Automne 2014\ProjetSession5\ProgrammeDuFESTO\Pro #
#                          grammeFESTO\UPSD\List\" -o                         #
#                          "C:\Synchro\Dropbox\Travaux\Automne                #
#                          2014\ProjetSession5\ProgrammeDuFESTO\ProgrammeFEST #
#                          O\UPSD\Obj\" -e --no_cse --no_unroll --no_inline   #
#                          --no_code_motion --no_tbaa --debug --core=plain    #
#                          --dptr=16,1 --data_model=large --code_model=near   #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data --nr_virtual_regs 8         #
#                          --dlib_config "C:\Program Files (x86)\IAR          #
#                          Systems\Embedded Workbench                         #
#                          6.0\8051\LIB\DLIB\dl8051Normal.h" -Ol --eec++      #
#    List file          =  C:\Synchro\Dropbox\Travaux\Automne                 #
#                          2014\ProjetSession5\ProgrammeDuFESTO\ProgrammeFEST #
#                          O\UPSD\List\CLCommunicUpsdPort1.lst                #
#    Object file        =  C:\Synchro\Dropbox\Travaux\Automne                 #
#                          2014\ProjetSession5\ProgrammeDuFESTO\ProgrammeFEST #
#                          O\UPSD\Obj\CLCommunicUpsdPort1.r51                 #
#                                                                             #
#                                                                             #
###############################################################################

C:\Synchro\Dropbox\Travaux\Automne 2014\ProjetSession5\ProgrammeDuFESTO\ProgrammeFESTO\CLCommunicUpsdPort1.cpp
      1          //**********************  Fichier: CLCommunic.cpp
      2          //  Description : Fonctions necessaire pour communiquer avec le port serie:
      3          //
      4          //
      5          //CLCommunic()                                         Constructeur par defaut
      6          //CLCommunic(UC ucLongBuf, UC ucLongTrame, UI uiBaud)  Construct initialisateur
      7          //~CLCommunic()                                        Destructeur
      8          //
      9          //UC ucInitLongTrame(UC ucLong)               Pour initialiser longueur trame
     10          //UC static ucLireNbCaractRecu()              Fct pour lire nombre de caractere recu
     11          //UC ucLireEtatTrame()                        Fct pour lire l'etat de la trame
     12          //char *ucpLireTrame()                        Fct qui retourne adresse du debut lecture
     13          //vend(UC ucCar)                              Fct pour transmettre un caractere
     14          //SendNumber(UI uiChiffreAAfficher)           Fct pour transmettre un chiffre
     15          //SendString(char const *ucpMessage)          Fct pour transmettre chaine de caractere
     16          //void vInitBaudRate(UI uiBaud)               Fct pour intialiser le baudrate et timer
     17          //__interrupt static void vInteruptSerial();  Fct pour recevoir un caractere
     18          //UC ucValideTrame()                          Fct pour valider une trame
     19          //
     20          //  Composition : aucune
     21          //  Heritage    : aucun
     22          //
     23          //  Programmeur : Vincent Chouinard
     24          //  Cours       : 247-436
     25          //
     26          //  Date        : 10 avril 2014
     27          //                                                                           //
     28          //  Compilateur : IAR 8.1
     29          //                                                                           //
     30          //  Modification:                                                            //
     31          //                                                                           //
     32          ///////////////////////////////////////////////////////////////////////////////
     33          #include "CLCommunicUpsdPort1.h"             //inclue CLCommunic.h.

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IE
   \                     _A_IE:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x99
   \   unsigned char volatile __sfr SBUF
   \                     SBUF:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x98
   \   union <unnamed> volatile __sfr _A_SCON
   \                     _A_SCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x87
   \   union <unnamed> volatile __sfr _A_PCON
   \                     _A_PCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x88
   \   union <unnamed> volatile __sfr _A_TCON
   \                     _A_TCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8d
   \   unsigned char volatile __sfr TH1
   \                     TH1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x89
   \   union <unnamed> volatile __sfr _A_TMOD
   \                     _A_TMOD:
   \   000000                DS 1
     34          #include "ConversionKeilToIAR.h"
     35          
     36           ///// Initialise les variables statiques.

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     37          UC    CLCommunic :: ucEtatTrame       = INCOMPLET      ; // Trame incomplete.
   \                     ??ucEtatTrame:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     38          UC    CLCommunic :: ucNbCaractRecu    = 0              ; // Nombre de caractere recu = 0
   \                     ??ucNbCaractRecu:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_I, align 1, keep-with-next
     39          UC    CLCommunic :: ucLongueurTrame   = LONGUEURTRAME  ; // Initialise les longueur du
   \                     ??ucLongueurTrame:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for ucLongueurTrame>`
   \   000001                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
     40          UC    CLCommunic :: ucLongueurTampon  = LONGUEURTAMPON ; // buffer et trame.
   \                     ??ucLongueurTampon:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for ucLongueurTampon>`
   \   000001                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     41          UC    CLCommunic :: ucCaractereRecu   = NULL           ;
   \                     ??ucCaractereRecu:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     42          UC    CLCommunic :: ucEtatReception   = INACTIF        ;
   \                     ??ucEtatReception:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     43          char *CLCommunic :: cpDebutTrame      = NULL           ; // Initialise lse pointeur a NULL.
   \                     ??cpDebutTrame:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     44          char *CLCommunic :: cpFinTrame        = NULL           ;
   \                     ??cpFinTrame:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     45          char *CLCommunic :: cptrEcriture      = NULL           ;
   \                     ??cptrEcriture:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     46          char *CLCommunic :: cptrLecture       = NULL           ;
   \                     ??cptrLecture:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     47          char *CLCommunic :: cTabCaractereRecu = NULL           ;
   \                     ??cTabCaractereRecu:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
     48          
     49          
     50          //*****************************************************************************
     51          // Nom de la fct       : CLCommunic(void)
     52          // Description         : Constructeur qui permet d'initialiser par defaut le port
     53          //                     : serie du micro controleur a  9600 bdr, un tampon de 12
     54          //                     : et une trame a 4 characteres. Initialise les differents
     55          //                     : pointeurs au debut et la la fin du tampon.
     56          //
     57          // INCLUDE             :#include "_TypeCible.h", "CLCommunic.h"
     58          // Prototype           : CLCommunic(void);
     59          //
     60          //
     61          // Parametre d'entree  : Aucune
     62          //
     63          // Parametre de sortie : Aucune
     64          //
     65          // Procedure appelees  : vInitBaudRate(),
     66          //
     67          // Exemple d'appel     : class CLCommunic clCommunic();
     68          //
     69          // Fait par            : Vincent Chouinard
     70          // Date                : 10 avril 2014
     71          // Revision            : A
     72          // Modification        :
     73          //*****************************************************************************

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
     74          CLCommunic::CLCommunic(void)
   \                     ??CLCommunic:
     75          {
   \   000000   74F8         MOV     A,#-0x8
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 8
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
     76           cTabCaractereRecu = new char[LONGUEURTAMPON]; // Definit tableau de longueur
   \   000009                ; Setup parameters for call to function operator new[](unsigned int)
   \   000009   7A0C         MOV     R2,#0xc
   \   00000B   7B00         MOV     R3,#0x0
   \   00000D   12....       LCALL   `??operator new[]`
   \   000010   90....       MOV     DPTR,#??cTabCaractereRecu
   \   000013   EA           MOV     A,R2
   \   000014   F0           MOVX    @DPTR,A
   \   000015   A3           INC     DPTR
   \   000016   EB           MOV     A,R3
   \   000017   F0           MOVX    @DPTR,A
     77                                                         // LONGUEURTAMPON.
     78           ucLongueurTrame  = LONGUEURTRAME;             // Definit longueur de la trame.
   \   000018   90....       MOV     DPTR,#??ucLongueurTrame
   \   00001B   7404         MOV     A,#0x4
   \   00001D   F0           MOVX    @DPTR,A
     79           ucLongueurTampon = LONGUEURTAMPON;            // Definit longueur tampon.
   \   00001E   90....       MOV     DPTR,#??ucLongueurTampon
   \   000021   740C         MOV     A,#0xc
   \   000023   F0           MOVX    @DPTR,A
     80          
     81           cpDebutTrame = &cTabCaractereRecu[0];                  // Pointeur sur debut tampon.
   \   000024   90....       MOV     DPTR,#??cTabCaractereRecu
   \   000027   E0           MOVX    A,@DPTR
   \   000028   F8           MOV     R0,A
   \   000029   A3           INC     DPTR
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F9           MOV     R1,A
   \   00002C   90....       MOV     DPTR,#??cpDebutTrame
   \   00002F   E8           MOV     A,R0
   \   000030   F0           MOVX    @DPTR,A
   \   000031   A3           INC     DPTR
   \   000032   E9           MOV     A,R1
   \   000033   F0           MOVX    @DPTR,A
     82           cpFinTrame   = &cTabCaractereRecu[(LONGUEURTAMPON-1)]; // Pointeur sur fin tampon
   \   000034   90....       MOV     DPTR,#??cTabCaractereRecu
   \   000037   E0           MOVX    A,@DPTR
   \   000038   240B         ADD     A,#0xb
   \   00003A   F8           MOV     R0,A
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   3400         ADDC    A,#0x0
   \   00003F   F9           MOV     R1,A
   \   000040   90....       MOV     DPTR,#??cpFinTrame
   \   000043   E8           MOV     A,R0
   \   000044   F0           MOVX    @DPTR,A
   \   000045   A3           INC     DPTR
   \   000046   E9           MOV     A,R1
   \   000047   F0           MOVX    @DPTR,A
     83           cptrEcriture = &cTabCaractereRecu[0];                  // Pointeur ecriture au debut.
   \   000048   90....       MOV     DPTR,#??cTabCaractereRecu
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   F8           MOV     R0,A
   \   00004D   A3           INC     DPTR
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   F9           MOV     R1,A
   \   000050   90....       MOV     DPTR,#??cptrEcriture
   \   000053   E8           MOV     A,R0
   \   000054   F0           MOVX    @DPTR,A
   \   000055   A3           INC     DPTR
   \   000056   E9           MOV     A,R1
   \   000057   F0           MOVX    @DPTR,A
     84           cptrLecture  = &cTabCaractereRecu[0];                  // Pointeur lecture au debut.
   \   000058   90....       MOV     DPTR,#??cTabCaractereRecu
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   F8           MOV     R0,A
   \   00005D   A3           INC     DPTR
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   F9           MOV     R1,A
   \   000060   90....       MOV     DPTR,#??cptrLecture
   \   000063   E8           MOV     A,R0
   \   000064   F0           MOVX    @DPTR,A
   \   000065   A3           INC     DPTR
   \   000066   E9           MOV     A,R1
   \   000067   F0           MOVX    @DPTR,A
     85          
     86           vInitBaudRate(9600);                                   // Initialise le port serie.
   \   000068                ; Setup parameters for call to function CLCommunic::vInitBaudRate(UI)
   \   000068   7C80         MOV     R4,#-0x80
   \   00006A   7D25         MOV     R5,#0x25
   \   00006C   EE           MOV     A,R6
   \   00006D   FA           MOV     R2,A
   \   00006E   EF           MOV     A,R7
   \   00006F   FB           MOV     R3,A
   \   000070   12....       LCALL   ??vInitBaudRate
     87          }
   \   000073   EE           MOV     A,R6
   \   000074   FA           MOV     R2,A
   \   000075   EF           MOV     A,R7
   \   000076   FB           MOV     R3,A
   \   000077   7F01         MOV     R7,#0x1
   \   000079   02....       LJMP    ?FUNC_LEAVE_XDATA
     88          
     89          
     90          //*****************************************************************************
     91          // Nom de la fct        : CLCommunic
     92          // Description          : Constructeur qui permet d'initialiser  le port
     93          //                        serie du micro controleur a  la vitesse voulue, un tampon
     94          //                        de taille dynamique et la longueur de la trame.
     95          //                        Initialise les differents pointeurs au debut et la la fin
     96          //                        du tampon.
     97          //
     98          // INCLUDE              : #include "_TypeCible.h", "CLCommunic.h"
     99          // Prototype            : CLCommunic(UC ucLongBuf, UC ucLongTrame, UI uiBaud);
    100          //
    101          //
    102          // Parametre d'entree   : ucLongBuf pour longueur du trableau
    103          //                        ucLongTrame pour longueur trame
    104          //                        uiBaud pour la vitesse du port serie
    105          //
    106          // Parametre de sortie  : Aucune
    107          //
    108          // Procedure appelees   : vInitBaudRate(), ucInitLongTrame()
    109          //
    110          // Exemple d'appel      : class CLCommunic clCommunic();
    111          //
    112          // Fait par             : Vincent Chouinard
    113          // Date                 : 10 avril 2014
    114          // Revision             : A
    115          // Modification         :
    116          //*****************************************************************************

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    117          CLCommunic :: CLCommunic(UC ucLongBuf, UC ucLongTrame, UI uiBaud)
   \                     ??CLCommunic_1:
    118          {
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   89..         MOV     ?V0 + 2,R1
   \   00000B   8C..         MOV     ?V0 + 3,R4
   \   00000D   740D         MOV     A,#0xd
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   E0           MOVX    A,@DPTR
   \   000013   FE           MOV     R6,A
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   FF           MOV     R7,A
    119           cTabCaractereRecu = new char[ucLongBuf]; // Initialise un tableau de longueur
   \   000017                ; Setup parameters for call to function operator new[](unsigned int)
   \   000017   85....       MOV     ?V0 + 4,?V0 + 2
   \   00001A   75..00       MOV     ?V0 + 5,#0x0
   \   00001D   AA..         MOV     R2,?V0 + 4
   \   00001F   AB..         MOV     R3,?V0 + 5
   \   000021   12....       LCALL   `??operator new[]`
   \   000024   90....       MOV     DPTR,#??cTabCaractereRecu
   \   000027   EA           MOV     A,R2
   \   000028   F0           MOVX    @DPTR,A
   \   000029   A3           INC     DPTR
   \   00002A   EB           MOV     A,R3
   \   00002B   F0           MOVX    @DPTR,A
    120                                                    // voulue.
    121           ucLongueurTampon = ucLongBuf;            // Longueur tampon = ucLongBuf.
   \   00002C   E5..         MOV     A,?V0 + 2
   \   00002E   90....       MOV     DPTR,#??ucLongueurTampon
   \   000031   F0           MOVX    @DPTR,A
    122           ucInitLongTrame(ucLongTrame);            // Verifie si longueur trame
   \   000032                ; Setup parameters for call to function CLCommunic::ucInitLongTrame(UC)
   \   000032   A9..         MOV     R1,?V0 + 3
   \   000034   AA..         MOV     R2,?V0 + 0
   \   000036   AB..         MOV     R3,?V0 + 1
   \   000038   12....       LCALL   ??ucInitLongTrame
   \   00003B   E9           MOV     A,R1
    123                                                    // < longueur tampon.
    124           cpDebutTrame = &cTabCaractereRecu[0];    // Pointeur pour debut tampon.
   \   00003C   90....       MOV     DPTR,#??cTabCaractereRecu
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   F8           MOV     R0,A
   \   000041   A3           INC     DPTR
   \   000042   E0           MOVX    A,@DPTR
   \   000043   F9           MOV     R1,A
   \   000044   90....       MOV     DPTR,#??cpDebutTrame
   \   000047   E8           MOV     A,R0
   \   000048   F0           MOVX    @DPTR,A
   \   000049   A3           INC     DPTR
   \   00004A   E9           MOV     A,R1
   \   00004B   F0           MOVX    @DPTR,A
    125           cpFinTrame   = &cTabCaractereRecu[(ucLongBuf-1)];// Pointeur pour fin tampon.
   \   00004C   E5..         MOV     A,?V0 + 2
   \   00004E   A8..         MOV     R0,?V0 + 2
   \   000050   7900         MOV     R1,#0x0
   \   000052   90....       MOV     DPTR,#??cTabCaractereRecu
   \   000055   E0           MOVX    A,@DPTR
   \   000056   28           ADD     A,R0
   \   000057   F8           MOV     R0,A
   \   000058   A3           INC     DPTR
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   39           ADDC    A,R1
   \   00005B   F9           MOV     R1,A
   \   00005C   E8           MOV     A,R0
   \   00005D   24FF         ADD     A,#-0x1
   \   00005F   F8           MOV     R0,A
   \   000060   E9           MOV     A,R1
   \   000061   34FF         ADDC    A,#-0x1
   \   000063   F9           MOV     R1,A
   \   000064   90....       MOV     DPTR,#??cpFinTrame
   \   000067   E8           MOV     A,R0
   \   000068   F0           MOVX    @DPTR,A
   \   000069   A3           INC     DPTR
   \   00006A   E9           MOV     A,R1
   \   00006B   F0           MOVX    @DPTR,A
    126           cptrEcriture = &cTabCaractereRecu[0];    // Pointeur ecriture et lecture au
   \   00006C   90....       MOV     DPTR,#??cTabCaractereRecu
   \   00006F   E0           MOVX    A,@DPTR
   \   000070   F8           MOV     R0,A
   \   000071   A3           INC     DPTR
   \   000072   E0           MOVX    A,@DPTR
   \   000073   F9           MOV     R1,A
   \   000074   90....       MOV     DPTR,#??cptrEcriture
   \   000077   E8           MOV     A,R0
   \   000078   F0           MOVX    @DPTR,A
   \   000079   A3           INC     DPTR
   \   00007A   E9           MOV     A,R1
   \   00007B   F0           MOVX    @DPTR,A
    127           cptrLecture  = &cTabCaractereRecu[0];    // debut du tampon.
   \   00007C   90....       MOV     DPTR,#??cTabCaractereRecu
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   F8           MOV     R0,A
   \   000081   A3           INC     DPTR
   \   000082   E0           MOVX    A,@DPTR
   \   000083   F9           MOV     R1,A
   \   000084   90....       MOV     DPTR,#??cptrLecture
   \   000087   E8           MOV     A,R0
   \   000088   F0           MOVX    @DPTR,A
   \   000089   A3           INC     DPTR
   \   00008A   E9           MOV     A,R1
   \   00008B   F0           MOVX    @DPTR,A
    128           vInitBaudRate(uiBaud);                   // Initialise la vitesse de
   \   00008C                ; Setup parameters for call to function CLCommunic::vInitBaudRate(UI)
   \   00008C   EE           MOV     A,R6
   \   00008D   FC           MOV     R4,A
   \   00008E   EF           MOV     A,R7
   \   00008F   FD           MOV     R5,A
   \   000090   AA..         MOV     R2,?V0 + 0
   \   000092   AB..         MOV     R3,?V0 + 1
   \   000094   12....       LCALL   ??vInitBaudRate
    129                                                    // communication.
    130          }
   \   000097   AA..         MOV     R2,?V0 + 0
   \   000099   AB..         MOV     R3,?V0 + 1
   \   00009B   7F06         MOV     R7,#0x6
   \   00009D   02....       LJMP    ?FUNC_LEAVE_XDATA
    131          
    132          //*****************************************************************************
    133          // Nom de la fct        :~CLCommunic
    134          // Description          : Desctructeur qui libert la memoire pris par le tampon.
    135          //
    136          // INCLUDE              : #include "_TypeCible.h", "CLCommunic.h"
    137          // Prototype            :~CLCommunic(void);
    138          //
    139          //
    140          // Parametre d'entree   : aucun
    141          //
    142          // Parametre de sortie  : Aucun
    143          //
    144          // Procedure appelees   : aucun
    145          //
    146          // Exemple d'appel      :
    147          //
    148          // Fait par             : Vincent Chouinard
    149          // Date                 : 10 avril 2014
    150          // Revision             : A
    151          // Modification         :
    152          //*****************************************************************************

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    153          CLCommunic :: ~CLCommunic(void)
   \                     `?~CLCommunic`:
    154          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    155          if(cTabCaractereRecu)              // Verification pour s'assurer que le
   \   000004   90....       MOV     DPTR,#??cTabCaractereRecu
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F8           MOV     R0,A
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F9           MOV     R1,A
   \   00000C   E8           MOV     A,R0
   \   00000D   49           ORL     A,R1
   \   00000E   6015         JZ      `?~CLCommunic_1`
    156            {                                // pointeur n'a pas deja ete libere
    157             delete cTabCaractereRecu;       // Libert la memoire prise par le tampon.
   \   000010                ; Setup parameters for call to function operator delete(void *)
   \   000010   90....       MOV     DPTR,#??cTabCaractereRecu
   \   000013   E0           MOVX    A,@DPTR
   \   000014   FA           MOV     R2,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   FB           MOV     R3,A
   \   000018   12....       LCALL   `??operator delete`
    158             cTabCaractereRecu = NULL;       // Pour mettre a 0 le pointeur.
   \   00001B   90....       MOV     DPTR,#??cTabCaractereRecu
   \   00001E   7400         MOV     A,#0x0
   \   000020   F0           MOVX    @DPTR,A
   \   000021   A3           INC     DPTR
   \   000022   7400         MOV     A,#0x0
   \   000024   F0           MOVX    @DPTR,A
    159            }
    160          }
   \                     `?~CLCommunic_1`:
   \   000025   D083         POP     DPH
   \   000027   D082         POP     DPL
   \   000029   22           RET
    161          
    162          //*****************************************************************************
    163          // Nom de la fct:   ucInitLongTrame
    164          // Description:     Verifie si la trame entree est inferieure au tampon
    165          //                  sinon la longueur de la trame = a celle du buffer.
    166          //
    167          // INCLUDE:        #include "_TypeCible.h", "CLCommunic.h"
    168          // Prototype:      UC ucInitLongTrame(UC ucLong);
    169          //
    170          //
    171          // Parametre d'entree: ucLong longueur voulue
    172          //
    173          // Parametre de sortie: ucValide pour valide ou non la taille
    174          //
    175          // Procedure appelees: aucun
    176          //
    177          // Exemple d'appel:  ucInitLongTrame(ucLongTrame);
    178          //
    179          // Fait par: Vincent Chouinard
    180          // Date:            10 avril 2014
    181          // Revision :       A
    182          // Modification :
    183          //*****************************************************************************
    184          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    185          UC CLCommunic :: ucInitLongTrame(UC ucLong)
   \                     ??ucInitLongTrame:
    186          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   F8           MOV     R0,A
    187          UC ucValide;                           // Varaible pour valider ou non.
    188          
    189          if(ucLong <= ucLongueurTampon)         // Si longueur trame voulue <= a la longueur
   \   000006   90....       MOV     DPTR,#??ucLongueurTampon
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   C3           CLR     C
   \   00000B   98           SUBB    A,R0
   \   00000C   4007         JC      ??ucInitLongTrame_1
    190            {                                    // du tampon.
    191             ucLongueurTrame = ucLong;           // longueur trame = longueur trame voulue.
   \   00000E   E8           MOV     A,R0
   \   00000F   90....       MOV     DPTR,#??ucLongueurTrame
   \   000012   F0           MOVX    @DPTR,A
    192             ucValide = VRAI;                    // ucValide = Vrai.
   \   000013   7901         MOV     R1,#0x1
    193            }
    194          
    195          if(ucLong > ucLongueurTampon)          // Si longueur trame voulue > a la longueur
   \                     ??ucInitLongTrame_1:
   \   000015   90....       MOV     DPTR,#??ucLongueurTampon
   \   000018   E0           MOVX    A,@DPTR
   \   000019   C3           CLR     C
   \   00001A   98           SUBB    A,R0
   \   00001B   500A         JNC     ??ucInitLongTrame_2
    196            {                                    // du tampon.
    197             ucLongueurTrame = ucLongueurTampon; // longueur trame = longueur tampon.
   \   00001D   90....       MOV     DPTR,#??ucLongueurTampon
   \   000020   E0           MOVX    A,@DPTR
   \   000021   90....       MOV     DPTR,#??ucLongueurTrame
   \   000024   F0           MOVX    @DPTR,A
    198             ucValide = FAUX;                    // ucValide = Faux.
   \   000025   7900         MOV     R1,#0x0
    199            }
    200          
    201          return(ucValide);                      // Retourne etat de ucValide.
   \                     ??ucInitLongTrame_2:
   \   000027   D083         POP     DPH
   \   000029   D082         POP     DPL
   \   00002B   22           RET
    202          }
    203          
    204          
    205          //*****************************************************************************
    206          // Nom de la fct:   ucValideTrame
    207          // Description:     Valide la trame recue, additionne tous les caracteres
    208          //                  recues et commpare avec le checksum.
    209          //
    210          // INCLUDE:        #include "_TypeCible.h", "CLCommunic.h"
    211          // Prototype:      UC ucValideTrame(void);
    212          //
    213          //
    214          // Parametre d'entre: aucun
    215          //
    216          // Parametre de sortie: ucValide pour valide ou non la trame.
    217          //
    218          // Procedure appelees: aucun
    219          //
    220          // Exemple d'appel: if(ucValideTrame() == VRAI)
    221          //
    222          // Fait par: Vincent Chouinard
    223          // Date:            10 avril 2014
    224          // Revision :       A
    225          // Modification :
    226          //*****************************************************************************

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    227          UC CLCommunic :: ucValideTrame(void)
   \                     ??ucValideTrame:
    228          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    229          UC ucValide;               // Variable pour etat valide ou non.
    230          UC ucSomme;                // variable pour la somme des caracteres recus.
    231          ucSomme = 0;               // Initialise la somme a 0.
   \   000004   7A00         MOV     R2,#0x0
    232          UC ucBoucle;               // Varialbe pour boucle.
    233          
    234          char *cPtrVerification;    // pointeur sur la tramme recu
    235          cPtrVerification = cptrLecture; // Intialise l'adresse du debut de la trame.
   \   000006   90....       MOV     DPTR,#??cptrLecture
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F8           MOV     R0,A
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F9           MOV     R1,A
    236          
    237          ucBoucle = (ucLongueurTrame - 1);         // Pour additionner toutes les valeurs
   \   00000E   90....       MOV     DPTR,#??ucLongueurTrame
   \   000011   E0           MOVX    A,@DPTR
   \   000012   24FF         ADD     A,#-0x1
   \   000014   FB           MOV     R3,A
   \   000015   8011         SJMP    ??ucValideTrame_1
    238                                                    // sauf le dernier
    239          for(;ucBoucle > 0; ucBoucle--)
    240            {
    241             ucSomme = *cPtrVerification + ucSomme; // Additionne le caractere avec somme.
   \                     ??ucValideTrame_2:
   \   000017   8882         MOV     DPL,R0
   \   000019   8983         MOV     DPH,R1
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   2A           ADD     A,R2
   \   00001D   FA           MOV     R2,A
    242             cPtrVerification ++;                   // Valeur suivante.
   \   00001E   8882         MOV     DPL,R0
   \   000020   8983         MOV     DPH,R1
   \   000022   A3           INC     DPTR
   \   000023   A882         MOV     R0,DPL
   \   000025   A983         MOV     R1,DPH
    243            }
   \   000027   1B           DEC     R3
   \                     ??ucValideTrame_1:
   \   000028   EB           MOV     A,R3
   \   000029   C3           CLR     C
   \   00002A   9401         SUBB    A,#0x1
   \   00002C   50E9         JNC     ??ucValideTrame_2
    244                                                    // Compare la somme avec le checksum recu.
    245          if(ucSomme == *cPtrVerification)          // Si egal?
   \   00002E   8882         MOV     DPL,R0
   \   000030   8983         MOV     DPH,R1
   \   000032   E0           MOVX    A,@DPTR
   \   000033   6A           XRL     A,R2
   \   000034   7004         JNZ     ??ucValideTrame_3
    246            {
    247             ucValide = VRAI;                       // Trame correcte.
   \   000036   7901         MOV     R1,#0x1
   \   000038   8002         SJMP    ??ucValideTrame_4
    248            }
    249          else                                      // Sinon
    250            {
    251             ucValide = FAUX;                       // Trame incorrecte.
   \                     ??ucValideTrame_3:
   \   00003A   7900         MOV     R1,#0x0
    252            }
    253          
    254          return(ucValide);                         // Retourne valide ou non.
   \                     ??ucValideTrame_4:
   \   00003C   D083         POP     DPH
   \   00003E   D082         POP     DPL
   \   000040   22           RET
    255          }
    256          
    257          //*****************************************************************************
    258          // Nom de la fct:   Send                  Fait par: Vincent Chouinard
    259          // Date:            2 octobre 2013
    260          // Revision :       A
    261          // Modification :
    262          // INCLUDE:         #include "_TypeCible.h", "CLCommunic.h"
    263          // Prototype:       void Send(UC ucCar);
    264          //
    265          // Description:     Fonction qui permet de transmettre un caractere par le port
    266          //                  serie, et on attend que le caractere soit completement
    267          //                  envoye par "polling" avec le flag TI_0.
    268          //
    269          // Parametre d'entree: ucCar: caractere qu'on veut envoyer.
    270          //
    271          //
    272          // Parametre de sortie: aucune
    273          //
    274          // Procedure appelees: aucune.
    275          //
    276          // Exemple d'appel: clCommunic.Send('A')
    277          //*****************************************************************************

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    278          void CLCommunic :: Send(UC ucCar)
   \                     ??Send:
    279          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    280          SBUF0 = ucCar;             // Envoye le caractere dans SBUF0 pour le transmetre sur TX
   \   000000   8999         MOV     0x99,R1
    281          while(TI_0 ==0);           // Si le flag TI_0 se met a 1 (termine)
   \                     ??Send_1:
   \   000002   A299         MOV     C,0x98.1
   \   000004   50FC         JNC     ??Send_1
    282          TI_0  = 0;                 // Remet le flag a 0.
   \   000006   C299         CLR     0x98.1
    283          }
   \   000008   22           RET
   \   000009                REQUIRE SBUF
   \   000009                REQUIRE _A_SCON
    284          
    285          
    286          
    287          //*****************************************************************************
    288          // Nom de la fct:   SendString
    289          // Description:     Transmet une chaine de caracteres sur le port serie.
    290          //
    291          // INCLUDE:        #include "_TypeCible.h", "CLCommunic.h"
    292          // Prototype:      void SendString(char const *ucpMessage)
    293          //
    294          //
    295          // Parametre d'entre: *ucpMessage pour chaine de caractere.
    296          //
    297          // Parametre de sortie: aucun
    298          //
    299          // Procedure appelees: Send()
    300          //
    301          // Exemple d'appel: clCommunic.SendString("TEST");
    302          //
    303          // Fait par: Vincent Chouinrd
    304          // Date:            10 avril 2014
    305          // Revision :       A
    306          // Modification :
    307          //*****************************************************************************

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    308          void CLCommunic :: SendString(char const *ucpMessage)
   \                     ??SendString:
    309          {
   \   000000   74F8         MOV     A,#-0x8
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 8
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C82         MOV     DPL,R4
   \   00000B   8D83         MOV     DPH,R5
   \   00000D   800A         SJMP    ??SendString_1
    310          while(*ucpMessage != 0x00)          // Tant qu'on a pas atteint la fin de
    311            {                                 // la chaine.
    312             Send(*ucpMessage);     // Transmet le caractere.
   \                     ??SendString_2:
   \   00000F                ; Setup parameters for call to function CLCommunic::Send(UC)
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F9           MOV     R1,A
   \   000011   EE           MOV     A,R6
   \   000012   FA           MOV     R2,A
   \   000013   EF           MOV     A,R7
   \   000014   FB           MOV     R3,A
   \   000015   12....       LCALL   ??Send
    313             ucpMessage++;                    // Passe au caractere suivant.
   \   000018   A3           INC     DPTR
    314            }
   \                     ??SendString_1:
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   70F3         JNZ     ??SendString_2
    315          }
   \   00001C   7F01         MOV     R7,#0x1
   \   00001E   02....       LJMP    ?FUNC_LEAVE_XDATA
    316          
    317          //*****************************************************************************
    318          // Nom de la fct:   ucLireNbCaractRecu                Fait par: VIncent Chouinard
    319          // Date:            2 octobre 2013
    320          // Revision :       A
    321          // Modification :
    322          // INCLUDE:         #include "_TypeCible.h", "CLCommunic.h"
    323          // Prototype:       UC ucLireNbCaractRecu(void);
    324          //
    325          // Description:     Fonction qui retourne le nombre de caractere recu.
    326          //
    327          //
    328          // Parametre d'entree: aucun
    329          //
    330          //
    331          // Parametre de sortie: ucNombreCaractere: nombre de caractere recu.
    332          //
    333          // Procedure appelees: aucune.
    334          //
    335          // Exemple d'appel: if(ucLireNbCaractRecu() < (ucLongueurTrame -1))
    336          //*****************************************************************************

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    337          UC CLCommunic :: ucLireNbCaractRecu(void)
   \                     ??ucLireNbCaractRecu:
    338          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    339          return(ucNbCaractRecu);          // Retourne le nombre de caractere recu.
   \   000004   90....       MOV     DPTR,#??ucNbCaractRecu
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009   D083         POP     DPH
   \   00000B   D082         POP     DPL
   \   00000D   22           RET
    340          }
    341          //*****************************************************************************
    342          // Nom de la fct:   ucLireEtatTrame                  Fait par: VIncent Chouinard
    343          // Date:            2 octobre 2013
    344          // Revision :       A
    345          // Modification :
    346          // INCLUDE:        #include "_TypeCible.h", "CLCommunic.h"
    347          // Prototype:       UC ucLireEtatTrame(void);
    348          //
    349          // Description:     Fonction qui permet de savoir si une trame est complete.
    350          //
    351          //
    352          // Parametre d'entree: aucun
    353          //
    354          //
    355          // Parametre de sortie: ucEtatTrameRecu: a 1 pour complete et 0 si imcomplete.
    356          //
    357          // Procedure appelees: aucune.
    358          //
    359          // Exemple d'appel:if(ucLireEtatTrame()==TRAMECOMPLET)
    360          //*****************************************************************************

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    361          UC CLCommunic :: ucLireEtatTrame(void)
   \                     ??ucLireEtatTrame:
    362          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    363          return(ucEtatTrame);            // Retourne l'etat de la trame.
   \   000004   90....       MOV     DPTR,#??ucEtatTrame
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009   D083         POP     DPH
   \   00000B   D082         POP     DPL
   \   00000D   22           RET
    364          }
    365          //*****************************************************************************
    366          // Nom de la fct:   *ucpLireTrame                   Fait par: Vincent Chouinard
    367          // Date:            2 octobre 2013
    368          // Revision :       A
    369          // Modification :
    370          // INCLUDE:         #include "_TypeCible.h", "CLCommunic.h"
    371          // Prototype:       UI *ucpLireTrame(void);
    372          //
    373          // Description:     Fonction qui permet de transmettre l'adresse du tableau
    374          //                  contenant la trame de caractere, et reinitialiser l'etat
    375          //                  de la  trame.
    376          //
    377          // Parametre d'entree: aucun
    378          //
    379          //
    380          // Parametre de sortie: uiTab: adresse du tableau.
    381          //
    382          // Procedure appelees: ucValideTrame()
    383          //
    384          // Exemple d'appel:Send('A')
    385          //*****************************************************************************

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    386          char *CLCommunic :: ucpLireTrame(void)
   \                     ??ucpLireTrame:
    387          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    388          char *ucptrLectAEnvoyer;           // Pointeur sur la trame recue.
    389          ucEtatTrame = INCOMPLET;           // Reinitialise l'etat de la trame.
   \   000004   90....       MOV     DPTR,#??ucEtatTrame
   \   000007   7400         MOV     A,#0x0
   \   000009   F0           MOVX    @DPTR,A
    390          
    391          if(ucValideTrame() == VRAI)        // Verifie si la trame est valide.
   \   00000A                ; Setup parameters for call to function CLCommunic::ucValideTrame()
   \   00000A   12....       LCALL   ??ucValideTrame
   \   00000D   E9           MOV     A,R1
   \   00000E   6401         XRL     A,#0x1
   \   000010   700A         JNZ     ??ucpLireTrame_1
    392            {                                // Si elle l'est
    393             ucptrLectAEnvoyer = cptrLecture;// transmet l'adresse du debut de la trame.
   \   000012   90....       MOV     DPTR,#??cptrLecture
   \   000015   E0           MOVX    A,@DPTR
   \   000016   FA           MOV     R2,A
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   FB           MOV     R3,A
   \   00001A   8004         SJMP    ??ucpLireTrame_2
    394            }
    395          else                               // Sinon
    396            {
    397             ucptrLectAEnvoyer = NULL;       // Ne transmet pas l'adresse du debut de
   \                     ??ucpLireTrame_1:
   \   00001C   7A00         MOV     R2,#0x0
   \   00001E   7B00         MOV     R3,#0x0
    398            }                                // la trame.
    399          return(ucptrLectAEnvoyer);         // Retourne l'adresse du tableau ou NULL.
   \                     ??ucpLireTrame_2:
   \   000020   D083         POP     DPH
   \   000022   D082         POP     DPL
   \   000024   22           RET
    400          }
    401          //*****************************************************************************
    402          // Nom de la fct:   vInitBaudRate                  Fait par: Vincent Chouinard
    403          // Date:            2 octobre 2013         version base
    404          //                  10 avril 2014          version avec uPSD.
    405          // Revision :       B
    406          // Modification :
    407          // INCLUDE:         #include "_TypeCible.h", "CLCommunic.h"
    408          // Prototype:       void vInitBaudRate(UI uiBaud);
    409          //
    410          // Description:     Fonction qui permet d' initialiser le port série au
    411          //                  baudrate desire, le timer 1(8 bit auto reload) et
    412          //                  les interuptions necessaire pour communiquer avec
    413          //                  le port serie.
    414          //                  Ajout de la compilation conditionnelle pour choix
    415          //                  de la valeur a mettre dans TH1 selon la cible.
    416          //
    417          // Parametre d'entree: UI uiBaud: pour determine la vitesse du baudrate.
    418          //
    419          //
    420          // Parametre de sortie: aucune
    421          //
    422          // Procedure appelees: aucune.
    423          //
    424          // Exemple d'appel: vInitBaudRate(57600);
    425          //*****************************************************************************

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    426          void CLCommunic:: vInitBaudRate(UI uiBaud)
   \                     ??vInitBaudRate:
    427          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    428          SCON0 = 0x50;         // SM0_0=0
   \   000005   759850       MOV     0x98,#0x50
    429                                // SM1_0=1
    430                                // SM2_0=0 pour longeur 10 bits et asychrone.
    431                                // REN_0=1 pour recevoir des caracteres.
    432          TMOD = TMOD | 0x20;   // M1=1
   \   000008   438920       ORL     0x89,#0x20
    433                                // M0=0 pour timer 8bit avec autoreload.
    434          PCON = PCON | 0x80;   // Pour doubler le baudrate (SMOD_0=1;).
   \   00000B   438780       ORL     0x87,#0x80
    435          
    436          #ifdef DALLAS89C450   // Si la cible est le Dallas
    437          
    438          switch(uiBaud)         // switch case pour determiner la valeur en
    439            {                    // hexa qui faut mettre a TH1 pour avoir la
    440                             // bonne vitesse du timer pour generer
    441             case 57600:         // le baudrate.
    442                TH1= 0xFF;
    443             break;
    444             case 38400:
    445                TH1= 0xFE;
    446             break;
    447             case 19200:
    448                TH1= 0xFD;
    449             break;
    450             case 9600:
    451                TH1= 0xFA;
    452             break;
    453             case 4800:
    454                TH1= 0xF4;
    455             break;
    456             case 2400:
    457                TH1= 0xE8;
    458             break;
    459             default:
    460                TH1= 0xFA;        // Si aucune valeur ne correspond vitesse = 9600 .
    461             break;
    462            }
    463          #endif
    464          
    465          #ifdef UPSD3254A        // Si la cible est le uPSD
    466          
    467          switch(uiBaud)         // switch case pour determiner la valeur en
   \   00000E   8C..         MOV     ?V0 + 0,R4
   \   000010   8D..         MOV     ?V0 + 1,R5
   \   000012   78..         MOV     R0,#?V0 + 0
   \   000014   12....       LCALL   ?US_SWITCH_SPARSE
   \                     `?<Jumptable for vInitBaudRate>_0`:
   \   000017   0000         DW        0
   \   000019   0300         DW        3
   \   00001B   6009         DW        2400
   \   00001D   ....         DW        ??vInitBaudRate_1
   \   00001F   C012         DW        4800
   \   000021   ....         DW        ??vInitBaudRate_2
   \   000023   8025         DW        9600
   \   000025   ....         DW        ??vInitBaudRate_3
   \   000027   ....         DW        ??vInitBaudRate_4
    468            {                    // hexa qui faut mettre a TH1 pour avoir la
    469                            // bonne vitesse du timer pour generer
    470              /*case 57600:      // le baudrate.
    471              TH1= 0xFE ;
    472              break;
    473              case 38400:        // uPSD ne peut aller a ces vitesses
    474              TH1= 0xFD;
    475              break;
    476              case 19200:
    477              TH1= 0xF9;
    478              break;*/
    479              case 9600:
    480                 TH1= 0xF3;
   \                     ??vInitBaudRate_3:
   \   000029   758DF3       MOV     0x8d,#-0xd
    481              break;
   \   00002C   800D         SJMP    ??vInitBaudRate_5
    482              case 4800:
    483                 TH1= 0xE6;
   \                     ??vInitBaudRate_2:
   \   00002E   758DE6       MOV     0x8d,#-0x1a
    484              break;
   \   000031   8008         SJMP    ??vInitBaudRate_5
    485              case 2400:
    486                 TH1= 0xCC;
   \                     ??vInitBaudRate_1:
   \   000033   758DCC       MOV     0x8d,#-0x34
    487              break;
   \   000036   8003         SJMP    ??vInitBaudRate_5
    488              default:
    489                 TH1= 0xF3;         // Si aucune valeur ne correspond vitesse = 9600 .
   \                     ??vInitBaudRate_4:
   \   000038   758DF3       MOV     0x8d,#-0xd
    490              break;
    491            }
    492          #endif
    493          
    494          TR1  = 1;      // Active le timer 1.
   \                     ??vInitBaudRate_5:
   \   00003B   D28E         SETB    0x88.6
    495          ET1  = 0;      // Desactive les interruptions du timer 1.
   \   00003D   C2AB         CLR     0xa8.3
    496          EA   = 1;      // Active les interruptions.
   \   00003F   D2AF         SETB    0xa8.7
    497          ES   = 1;      // Active les interruptions du port serie.
   \   000041   D2AC         SETB    0xa8.4
    498          TI_0 = 0;      // Met a 0 le drapeau de la transmision serie.
   \   000043   C299         CLR     0x98.1
    499          }
   \   000045   7F02         MOV     R7,#0x2
   \   000047   02....       LJMP    ?FUNC_LEAVE_XDATA
   \   00004A                REQUIRE _A_SCON
   \   00004A                REQUIRE _A_TMOD
   \   00004A                REQUIRE _A_PCON
   \   00004A                REQUIRE TH1
   \   00004A                REQUIRE _A_TCON
   \   00004A                REQUIRE _A_IE
    500          
    501          //*****************************************************************************
    502          // Nom de la fct:   vInteruptSerial                  Fait par: VIncent CHouinard
    503          // Date:            2 octobre 2013
    504          //
    505          // Revision :       B
    506          // Modification :   10 avril 2014     conversion pour IAR
    507          //
    508          // INCLUDE:         #include "_TypeCible.h", "CLCommunic.h"
    509          // Prototype:       __interrupt  void CLCommunic:: vInteruptSerial(void);
    510          //
    511          // Description:     Fonction qui permet de recevoir des caracteres par le port
    512          //                  serie, si l'interruption vient de la reception on place
    513          //                  les caracteres lus dans un tableau.
    514          //
    515          // Parametre d'entree: aucun.
    516          //
    517          //
    518          // Parametre de sortie: valeur dans cptrLecture pour lire les caractere recus.
    519          //
    520          // Procedure appelees: ucLireNbCaractRecu(),
    521          //
    522          // Exemple d'appel: aucun
    523          //*****************************************************************************
    524          #pragma vector=0x23  // Interrupt 4 pour interruption serie au vecteur 23

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    525           __interrupt  void CLCommunic:: vInteruptSerial(void)
   \                     ??vInteruptSerial:
    526          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 15
   \   000007                ; Auto size: 0
    527          EA = 0;                               // Desactive les interruptions.
   \   000007   C2AF         CLR     0xa8.7
    528          
    529          if(RI_0==1)                           // Interruption cause par la reception?
   \   000009   A298         MOV     C,0x98.0
   \   00000B   4003         JC      $+5
   \   00000D   02....       LJMP    ??vInteruptSerial_1
    530            {
    531             if(cptrEcriture > cpFinTrame)      // Si on a atteind la fin du buffer
   \   000010   90....       MOV     DPTR,#??cpFinTrame
   \   000013   C082         PUSH    DPL
   \   000015   C083         PUSH    DPH
   \   000017   90....       MOV     DPTR,#??cptrEcriture
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F8           MOV     R0,A
   \   00001C   A3           INC     DPTR
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   F9           MOV     R1,A
   \   00001F   D083         POP     DPH
   \   000021   D082         POP     DPL
   \   000023   C3           CLR     C
   \   000024   E0           MOVX    A,@DPTR
   \   000025   98           SUBB    A,R0
   \   000026   A3           INC     DPTR
   \   000027   E0           MOVX    A,@DPTR
   \   000028   99           SUBB    A,R1
   \   000029   5010         JNC     ??vInteruptSerial_2
    532               {
    533                cptrEcriture = cpDebutTrame;    // Retourne au debut du tampon.
   \   00002B   90....       MOV     DPTR,#??cpDebutTrame
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   F8           MOV     R0,A
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   F9           MOV     R1,A
   \   000033   90....       MOV     DPTR,#??cptrEcriture
   \   000036   E8           MOV     A,R0
   \   000037   F0           MOVX    @DPTR,A
   \   000038   A3           INC     DPTR
   \   000039   E9           MOV     A,R1
   \   00003A   F0           MOVX    @DPTR,A
    534               }
    535          
    536            *cptrEcriture    = SBUF0;  // Lit dans SBUF0 le caractere recu et met dans le tableau.
   \                     ??vInteruptSerial_2:
   \   00003B   E599         MOV     A,0x99
   \   00003D   C0E0         PUSH    A
   \   00003F   90....       MOV     DPTR,#??cptrEcriture
   \   000042   E0           MOVX    A,@DPTR
   \   000043   F8           MOV     R0,A
   \   000044   A3           INC     DPTR
   \   000045   E0           MOVX    A,@DPTR
   \   000046   F583         MOV     DPH,A
   \   000048   8882         MOV     DPL,R0
   \   00004A   D0E0         POP     A
   \   00004C   F0           MOVX    @DPTR,A
    537             ucCaractereRecu = SBUF0;
   \   00004D   E599         MOV     A,0x99
   \   00004F   90....       MOV     DPTR,#??ucCaractereRecu
   \   000052   F0           MOVX    @DPTR,A
    538             ucEtatReception = ACTIF;
   \   000053   90....       MOV     DPTR,#??ucEtatReception
   \   000056   7401         MOV     A,#0x1
   \   000058   F0           MOVX    @DPTR,A
    539             cptrEcriture++;           // Increment la position du pointeur d'ecriture.
   \   000059   90....       MOV     DPTR,#??cptrEcriture
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   2401         ADD     A,#0x1
   \   00005F   F8           MOV     R0,A
   \   000060   A3           INC     DPTR
   \   000061   E0           MOVX    A,@DPTR
   \   000062   3400         ADDC    A,#0x0
   \   000064   F9           MOV     R1,A
   \   000065   90....       MOV     DPTR,#??cptrEcriture
   \   000068   E8           MOV     A,R0
   \   000069   F0           MOVX    @DPTR,A
   \   00006A   A3           INC     DPTR
   \   00006B   E9           MOV     A,R1
   \   00006C   F0           MOVX    @DPTR,A
    540          
    541             if(ucLireNbCaractRecu() < (ucLongueurTrame - 1) )
   \   00006D                ; Setup parameters for call to function CLCommunic::ucLireNbCaractRecu()
   \   00006D   12....       LCALL   ??ucLireNbCaractRecu
   \   000070   E9           MOV     A,R1
   \   000071   FA           MOV     R2,A
   \   000072   7B00         MOV     R3,#0x0
   \   000074   90....       MOV     DPTR,#??ucLongueurTrame
   \   000077   E0           MOVX    A,@DPTR
   \   000078   F8           MOV     R0,A
   \   000079   7900         MOV     R1,#0x0
   \   00007B   24FF         ADD     A,#-0x1
   \   00007D   F8           MOV     R0,A
   \   00007E   E9           MOV     A,R1
   \   00007F   34FF         ADDC    A,#-0x1
   \   000081   F9           MOV     R1,A
   \   000082   C3           CLR     C
   \   000083   EA           MOV     A,R2
   \   000084   98           SUBB    A,R0
   \   000085   EB           MOV     A,R3
   \   000086   99           SUBB    A,R1
   \   000087   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000089   65D0         XRL     A,PSW
   \   00008B   33           RLC     A
   \   00008C   5009         JNC     ??vInteruptSerial_3
    542               {                       // Si le nombre de caractere recu est inferieur a
    543                ucNbCaractRecu++;      // trame - 1 incremente le nombre de caracteres
   \   00008E   90....       MOV     DPTR,#??ucNbCaractRecu
   \   000091   E0           MOVX    A,@DPTR
   \   000092   2401         ADD     A,#0x1
   \   000094   F0           MOVX    @DPTR,A
   \   000095   802C         SJMP    ??vInteruptSerial_4
    544               }                       // recus.
    545             else                      // Si la trame est complete?
    546               {
    547                ucNbCaractRecu=0;      // Remet a 0 le compte de caractere.
   \                     ??vInteruptSerial_3:
   \   000097   90....       MOV     DPTR,#??ucNbCaractRecu
   \   00009A   7400         MOV     A,#0x0
   \   00009C   F0           MOVX    @DPTR,A
    548                ucEtatTrame = COMPLET; // Indique qu'une trame est complete.
   \   00009D   90....       MOV     DPTR,#??ucEtatTrame
   \   0000A0   7401         MOV     A,#0x1
   \   0000A2   F0           MOVX    @DPTR,A
    549                cptrLecture = (cptrEcriture - (ucLongueurTrame));
   \   0000A3   90....       MOV     DPTR,#??ucLongueurTrame
   \   0000A6   E0           MOVX    A,@DPTR
   \   0000A7   F8           MOV     R0,A
   \   0000A8   7900         MOV     R1,#0x0
   \   0000AA   C3           CLR     C
   \   0000AB   E4           CLR     A
   \   0000AC   98           SUBB    A,R0
   \   0000AD   F8           MOV     R0,A
   \   0000AE   E4           CLR     A
   \   0000AF   99           SUBB    A,R1
   \   0000B0   F9           MOV     R1,A
   \   0000B1   90....       MOV     DPTR,#??cptrEcriture
   \   0000B4   E0           MOVX    A,@DPTR
   \   0000B5   28           ADD     A,R0
   \   0000B6   F8           MOV     R0,A
   \   0000B7   A3           INC     DPTR
   \   0000B8   E0           MOVX    A,@DPTR
   \   0000B9   39           ADDC    A,R1
   \   0000BA   F9           MOV     R1,A
   \   0000BB   90....       MOV     DPTR,#??cptrLecture
   \   0000BE   E8           MOV     A,R0
   \   0000BF   F0           MOVX    @DPTR,A
   \   0000C0   A3           INC     DPTR
   \   0000C1   E9           MOV     A,R1
   \   0000C2   F0           MOVX    @DPTR,A
    550                                       // Le pointeur de lecture = la position
    551                                       // d'ecriture - la longuer de la trame.
    552               }
    553             RI_0 = 0;                 // Reinitialiser le flag de reception.
   \                     ??vInteruptSerial_4:
   \   0000C3   C298         CLR     0x98.0
    554           }                           // Fin du if(RI_0 = 1)
    555          EA = 1;                      // Reactive les interruptions
   \                     ??vInteruptSerial_1:
   \   0000C5   D2AF         SETB    0xa8.7
    556          }                            // Fin de Interruption.
   \   0000C7   7F01         MOV     R7,#0x1
   \   0000C9   02....       LJMP    ?INTERRUPT_LEAVE_XSP
   \   0000CC                REQUIRE _A_IE
   \   0000CC                REQUIRE _A_SCON
   \   0000CC                REQUIRE SBUF
    557          
    558          //*****************************************************************************
    559          // Nom de la fct:   SendNumber
    560          // Description:     Fonction qui permet transmettre  un nombre de 0 a
    561          //                  65000 sur le port serie.
    562          // INCLUDE:       #include "_TypeCible.h", "CLCommunic.h"
    563          // Prototype:     void SendNumber(UI uiChiffreAAfficher);
    564          //
    565          //
    566          // Parametre d'entree: uiChiffreAAfficher pour chiffre a afficher
    567          //
    568          // Parametre de sortie: aucun
    569          //
    570          // Procedure appelees: Send();
    571          //
    572          //
    573          // Exemple d'appel: vLcdAffChiffre(12345)
    574          //
    575          // Fait par: Vincent Chouinard
    576          // Date:            14 novembre 2013
    577          // Revision :       A
    578          // Modification :
    579          //*****************************************************************************

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    580          void CLCommunic :: SendNumber(UI uiChiffreAAfficher)
   \                     ??SendNumber:
    581          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
    582          UC ucChiffre0; // Declaration des variables
    583          UC ucChiffre1;
    584          UC ucChiffre2;
    585          UC ucChiffre3;
    586          UC ucChiffre4; // isole chaque chiffre du nombre.
    587          
    588          ucChiffre0 = ((uiChiffreAAfficher  % 10)    + 0x30);       // Unitee.
   \   000009   EC           MOV     A,R4
   \   00000A   F8           MOV     R0,A
   \   00000B   ED           MOV     A,R5
   \   00000C   F9           MOV     R1,A
   \   00000D   7A0A         MOV     R2,#0xa
   \   00000F   7B00         MOV     R3,#0x0
   \   000011   12....       LCALL   ?US_DIV_MOD
   \   000014   EA           MOV     A,R2
   \   000015   2430         ADD     A,#0x30
   \   000017   F5..         MOV     ?V0 + 2,A
    589          ucChiffre1 = (((uiChiffreAAfficher / 10)    % 10) + 0x30); // Dizaine
   \   000019   EC           MOV     A,R4
   \   00001A   F8           MOV     R0,A
   \   00001B   ED           MOV     A,R5
   \   00001C   F9           MOV     R1,A
   \   00001D   7A0A         MOV     R2,#0xa
   \   00001F   7B00         MOV     R3,#0x0
   \   000021   12....       LCALL   ?US_DIV_MOD
   \   000024   7A0A         MOV     R2,#0xa
   \   000026   7B00         MOV     R3,#0x0
   \   000028   12....       LCALL   ?US_DIV_MOD
   \   00002B   EA           MOV     A,R2
   \   00002C   2430         ADD     A,#0x30
   \   00002E   F5..         MOV     ?V0 + 1,A
    590          ucChiffre2 = (((uiChiffreAAfficher / 100)   % 10) + 0x30); // Centaine.
   \   000030   EC           MOV     A,R4
   \   000031   F8           MOV     R0,A
   \   000032   ED           MOV     A,R5
   \   000033   F9           MOV     R1,A
   \   000034   7A64         MOV     R2,#0x64
   \   000036   7B00         MOV     R3,#0x0
   \   000038   12....       LCALL   ?US_DIV_MOD
   \   00003B   7A0A         MOV     R2,#0xa
   \   00003D   7B00         MOV     R3,#0x0
   \   00003F   12....       LCALL   ?US_DIV_MOD
   \   000042   EA           MOV     A,R2
   \   000043   2430         ADD     A,#0x30
   \   000045   F5..         MOV     ?V0 + 0,A
    591          ucChiffre3 = (((uiChiffreAAfficher / 1000)  % 10) + 0x30); // Millier.
   \   000047   EC           MOV     A,R4
   \   000048   F8           MOV     R0,A
   \   000049   ED           MOV     A,R5
   \   00004A   F9           MOV     R1,A
   \   00004B   7AE8         MOV     R2,#-0x18
   \   00004D   7B03         MOV     R3,#0x3
   \   00004F   12....       LCALL   ?US_DIV_MOD
   \   000052   7A0A         MOV     R2,#0xa
   \   000054   7B00         MOV     R3,#0x0
   \   000056   12....       LCALL   ?US_DIV_MOD
   \   000059   EA           MOV     A,R2
   \   00005A   2430         ADD     A,#0x30
   \   00005C   FE           MOV     R6,A
    592          ucChiffre4 = ((uiChiffreAAfficher  / 10000) + 0x30);       // Dizaine de mille.
   \   00005D   EC           MOV     A,R4
   \   00005E   F8           MOV     R0,A
   \   00005F   ED           MOV     A,R5
   \   000060   F9           MOV     R1,A
   \   000061   7A10         MOV     R2,#0x10
   \   000063   7B27         MOV     R3,#0x27
   \   000065   12....       LCALL   ?US_DIV_MOD
   \   000068   E8           MOV     A,R0
   \   000069   2430         ADD     A,#0x30
   \   00006B   FF           MOV     R7,A
    593          
    594          if(ucChiffre4 != 0x30)                 // Si Dizaine de mille  = 0
   \   00006C   7430         MOV     A,#0x30
   \   00006E   6F           XRL     A,R7
   \   00006F   6009         JZ      ??SendNumber_1
    595            {                                    // Ne l'affiche pas
    596             Send(ucChiffre4);                   // Transmet les Dizaine de mille.
   \   000071                ; Setup parameters for call to function CLCommunic::Send(UC)
   \   000071   EF           MOV     A,R7
   \   000072   F9           MOV     R1,A
   \   000073   AA82         MOV     R2,DPL
   \   000075   AB83         MOV     R3,DPH
   \   000077   12....       LCALL   ??Send
    597            }
    598          
    599          if((ucChiffre4 != 0x30) || (ucChiffre3 != 0x30))// Si les 2 premiers chiffres
   \                     ??SendNumber_1:
   \   00007A   7430         MOV     A,#0x30
   \   00007C   6F           XRL     A,R7
   \   00007D   7005         JNZ     ??SendNumber_2
   \   00007F   7430         MOV     A,#0x30
   \   000081   6E           XRL     A,R6
   \   000082   6009         JZ      ??SendNumber_3
    600            {                                             // sont different de 0.
    601             Send(ucChiffre3);                            // Transmet les millier.
   \                     ??SendNumber_2:
   \   000084                ; Setup parameters for call to function CLCommunic::Send(UC)
   \   000084   EE           MOV     A,R6
   \   000085   F9           MOV     R1,A
   \   000086   AA82         MOV     R2,DPL
   \   000088   AB83         MOV     R3,DPH
   \   00008A   12....       LCALL   ??Send
    602            }
    603          
    604          if((ucChiffre4 != 0x30) || (ucChiffre3 != 0x30)||(ucChiffre2 != 0x30))
   \                     ??SendNumber_3:
   \   00008D   7430         MOV     A,#0x30
   \   00008F   6F           XRL     A,R7
   \   000090   700B         JNZ     ??SendNumber_4
   \   000092   7430         MOV     A,#0x30
   \   000094   6E           XRL     A,R6
   \   000095   7006         JNZ     ??SendNumber_4
   \   000097   7430         MOV     A,#0x30
   \   000099   65..         XRL     A,?V0 + 0
   \   00009B   6009         JZ      ??SendNumber_5
    605            {                                  // Si les 3 1er chiffres sont different
    606                                               // de 0?
    607             Send(ucChiffre2);                 // Transmet les centaines.
   \                     ??SendNumber_4:
   \   00009D                ; Setup parameters for call to function CLCommunic::Send(UC)
   \   00009D   A9..         MOV     R1,?V0 + 0
   \   00009F   AA82         MOV     R2,DPL
   \   0000A1   AB83         MOV     R3,DPH
   \   0000A3   12....       LCALL   ??Send
    608            }
    609          
    610          if((ucChiffre4 != 0x30)||(ucChiffre3 != 0x30)||(ucChiffre2 != 0x30)||(ucChiffre1 != 0x30))
   \                     ??SendNumber_5:
   \   0000A6   7430         MOV     A,#0x30
   \   0000A8   6F           XRL     A,R7
   \   0000A9   7011         JNZ     ??SendNumber_6
   \   0000AB   7430         MOV     A,#0x30
   \   0000AD   6E           XRL     A,R6
   \   0000AE   700C         JNZ     ??SendNumber_6
   \   0000B0   7430         MOV     A,#0x30
   \   0000B2   65..         XRL     A,?V0 + 0
   \   0000B4   7006         JNZ     ??SendNumber_6
   \   0000B6   7430         MOV     A,#0x30
   \   0000B8   65..         XRL     A,?V0 + 1
   \   0000BA   6009         JZ      ??SendNumber_7
    611                                            // Si les 4 premier chiffres sont
    612            {                              // different de 0.
    613             Send(ucChiffre1);             // Transmet les dizianes.
   \                     ??SendNumber_6:
   \   0000BC                ; Setup parameters for call to function CLCommunic::Send(UC)
   \   0000BC   A9..         MOV     R1,?V0 + 1
   \   0000BE   AA82         MOV     R2,DPL
   \   0000C0   AB83         MOV     R3,DPH
   \   0000C2   12....       LCALL   ??Send
    614            }
    615           Send(ucChiffre0);               // Transmetles unitees.
   \                     ??SendNumber_7:
   \   0000C5                ; Setup parameters for call to function CLCommunic::Send(UC)
   \   0000C5   A9..         MOV     R1,?V0 + 2
   \   0000C7   AA82         MOV     R2,DPL
   \   0000C9   AB83         MOV     R3,DPH
   \   0000CB   12....       LCALL   ??Send
    616          }
   \   0000CE   7F03         MOV     R7,#0x3
   \   0000D0   02....       LJMP    ?FUNC_LEAVE_XDATA
    617          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    618          UC CLCommunic :: GetChar(void)
   \                     ??GetChar:
    619          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    620          ucEtatReception = INACTIF;
   \   000004   90....       MOV     DPTR,#??ucEtatReception
   \   000007   7400         MOV     A,#0x0
   \   000009   F0           MOVX    @DPTR,A
    621          return(ucCaractereRecu);
   \   00000A   90....       MOV     DPTR,#??ucCaractereRecu
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F9           MOV     R1,A
   \   00000F   D083         POP     DPH
   \   000011   D082         POP     DPL
   \   000013   22           RET
    622          }
    623          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    624          UC CLCommunic :: ucLireEtatReception(void)
   \                     ??ucLireEtatReception:
    625          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    626          return(ucEtatReception);            // Retourne l'etat de la trame.
   \   000004   90....       MOV     DPTR,#??ucEtatReception
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009   D083         POP     DPH
   \   00000B   D082         POP     DPL
   \   00000D   22           RET
    627          }

   \                                 In  segment INTVEC, offset 0x23, root
   \                     `??vInteruptSerial??INTVEC 35`:
   \   000023   02....       LJMP       (??vInteruptSerial)

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ucLongueurTrame>`:
   \   000000   04           DB 4

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ucLongueurTampon>`:
   \   000000   0C           DB 12

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \   __near_func __xdata_reentrant CLCommunic &CLCommunic::new CLCommunic()
   \                     `??new CLCommunic`:
   \   000000   C0..         PUSH    ?V0 + 0
   \   000002   C0..         PUSH    ?V0 + 1
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004                ; Setup parameters for call to function operator new(unsigned int)
   \   000004   7A01         MOV     R2,#0x1
   \   000006   7B00         MOV     R3,#0x0
   \   000008   12....       LCALL   `??operator new`
   \   00000B   8A..         MOV     ?V0 + 0,R2
   \   00000D   8B..         MOV     ?V0 + 1,R3
   \   00000F   A8..         MOV     R0,?V0 + 0
   \   000011   A9..         MOV     R1,?V0 + 1
   \   000013   E8           MOV     A,R0
   \   000014   FA           MOV     R2,A
   \   000015   E9           MOV     A,R1
   \   000016   FB           MOV     R3,A
   \   000017   E8           MOV     A,R0
   \   000018   49           ORL     A,R1
   \   000019   600D         JZ      `??new CLCommunic_2`
   \   00001B                ; Setup parameters for call to function CLCommunic::CLCommunic()
   \   00001B   12....       LCALL   ??CLCommunic
   \   00001E   8A..         MOV     ?V0 + 0,R2
   \   000020   8B..         MOV     ?V0 + 1,R3
   \   000022   AA..         MOV     R2,?V0 + 0
   \   000024   AB..         MOV     R3,?V0 + 1
   \   000026   8004         SJMP    `??new CLCommunic_3`
   \                     `??new CLCommunic_2`:
   \   000028   7A00         MOV     R2,#0x0
   \   00002A   7B00         MOV     R3,#0x0
   \                     `??new CLCommunic_3`:
   \   00002C   D0..         POP     ?V0 + 1
   \   00002E   D0..         POP     ?V0 + 0
   \   000030   22           RET

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \   __near_func __xdata_reentrant CLCommunic &CLCommunic::new CLCommunic(UC, UC, UI)
   \                     `??new CLCommunic_1`:
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   \   000007   EA           MOV     A,R2
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0 + 0,R4
   \   00000B   8D..         MOV     ?V0 + 1,R5
   \   00000D                ; Setup parameters for call to function operator new(unsigned int)
   \   00000D   7A01         MOV     R2,#0x1
   \   00000F   7B00         MOV     R3,#0x0
   \   000011   12....       LCALL   `??operator new`
   \   000014   8A..         MOV     ?V0 + 2,R2
   \   000016   8B..         MOV     ?V0 + 3,R3
   \   000018   A8..         MOV     R0,?V0 + 2
   \   00001A   A9..         MOV     R1,?V0 + 3
   \   00001C   E8           MOV     A,R0
   \   00001D   FA           MOV     R2,A
   \   00001E   E9           MOV     A,R1
   \   00001F   FB           MOV     R3,A
   \   000020   E8           MOV     A,R0
   \   000021   49           ORL     A,R1
   \   000022   601B         JZ      `??new CLCommunic_4`
   \   000024                ; Setup parameters for call to function CLCommunic::CLCommunic(UC, UC, UI)
   \   000024   78..         MOV     R0,#?V0 + 0
   \   000026   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000029   EF           MOV     A,R7
   \   00002A   FC           MOV     R4,A
   \   00002B   EE           MOV     A,R6
   \   00002C   F9           MOV     R1,A
   \   00002D   12....       LCALL   ??CLCommunic_1
   \   000030   7402         MOV     A,#0x2
   \   000032   12....       LCALL   ?DEALLOC_XSTACK8
   \   000035   8A..         MOV     ?V0 + 0,R2
   \   000037   8B..         MOV     ?V0 + 1,R3
   \   000039   AA..         MOV     R2,?V0 + 0
   \   00003B   AB..         MOV     R3,?V0 + 1
   \   00003D   8004         SJMP    `??new CLCommunic_5`
   \                     `??new CLCommunic_4`:
   \   00003F   7A00         MOV     R2,#0x0
   \   000041   7B00         MOV     R3,#0x0
   \                     `??new CLCommunic_5`:
   \   000043   7F04         MOV     R7,#0x4
   \   000045   02....       LJMP    ?FUNC_LEAVE_XDATA

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \   __near_func __xdata_reentrant void CLCommunic::delete ~CLCommunic(CLCommunic *)
   \                     `??delete ~CLCommunic`:
   \   000000   74F8         MOV     A,#-0x8
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 8
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   EE           MOV     A,R6
   \   00000A   4F           ORL     A,R7
   \   00000B   600E         JZ      `??delete ~CLCommunic_1`
   \   00000D                ; Setup parameters for call to function CLCommunic::~CLCommunic()
   \   00000D   EE           MOV     A,R6
   \   00000E   FA           MOV     R2,A
   \   00000F   EF           MOV     A,R7
   \   000010   FB           MOV     R3,A
   \   000011   12....       LCALL   `?~CLCommunic`
   \   000014                ; Setup parameters for call to function operator delete(void *)
   \   000014   EE           MOV     A,R6
   \   000015   FA           MOV     R2,A
   \   000016   EF           MOV     A,R7
   \   000017   FB           MOV     R3,A
   \   000018   12....       LCALL   `??operator delete`
   \                     `??delete ~CLCommunic_1`:
   \   00001B   7F01         MOV     R7,#0x1
   \   00001D   02....       LJMP    ?FUNC_LEAVE_XDATA
    628          
    629          
    630          //LinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxTUX
    631          
    632          
    633          
    634          
    635          
    636          

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     CLCommunic::CLCommunic()           0      0      8
       -> operator new[](unsigned int)
                                        0      0     16
       -> CLCommunic::vInitBaudRate(UI)
                                        0      0     16
     CLCommunic::CLCommunic(UC, UC, UI)
                                        0      0     26
       -> operator new[](unsigned int)
                                        0      0     26
       -> CLCommunic::ucInitLongTrame(UC)
                                        0      0     26
       -> CLCommunic::vInitBaudRate(UI)
                                        0      0     26
     CLCommunic::GetChar()              2      0      0
     CLCommunic::Send(UC)               0      0     10
     CLCommunic::SendNumber(UI)         0      0     10
       -> CLCommunic::Send(UC)          0      0     20
       -> CLCommunic::Send(UC)          0      0     20
       -> CLCommunic::Send(UC)          0      0     20
       -> CLCommunic::Send(UC)          0      0     20
       -> CLCommunic::Send(UC)          0      0     20
     CLCommunic::SendString(char const *)
                                        0      0      8
       -> CLCommunic::Send(UC)          0      0     16
     CLCommunic::delete ~CLCommunic(CLCommunic *)
                                        0      0      8
       -> CLCommunic::~CLCommunic()     0      0     16
       -> operator delete(void *)       0      0     16
     CLCommunic::new CLCommunic()       2      0      0
       -> operator new(unsigned int)
                                        4      0      0
       -> CLCommunic::CLCommunic()      4      0      0
     CLCommunic::new CLCommunic(UC, UC, UI)
                                        0      0     13
       -> operator new(unsigned int)
                                        0      0     22
       -> CLCommunic::CLCommunic(UC, UC, UI)
                                        0      0     26
     CLCommunic::ucInitLongTrame(UC)
                                        2      0     13
     CLCommunic::ucLireEtatReception()
                                        2      0      0
     CLCommunic::ucLireEtatTrame()      2      0      0
     CLCommunic::ucLireNbCaractRecu()
                                        2      0      0
     CLCommunic::ucValideTrame()        2      0      0
     CLCommunic::ucpLireTrame()         2      0      0
       -> CLCommunic::ucValideTrame()
                                        4      0      0
     CLCommunic::vInitBaudRate(UI)      0      0     22
     CLCommunic::vInteruptSerial()     17      0      0
       -> CLCommunic::ucLireNbCaractRecu()
                                       30      0      0
     CLCommunic::~CLCommunic()          2      0      8
       -> operator delete(void *)       4      0      0


   Segment part sizes:

     Function/Label                      Bytes
     --------------                      -----
     _A_IE                                  1
     SBUF                                   1
     _A_SCON                                1
     _A_PCON                                1
     _A_TCON                                1
     TH1                                    1
     _A_TMOD                                1
     CLCommunic::ucEtatTrame                1
     CLCommunic::ucNbCaractRecu             1
     CLCommunic::ucLongueurTrame            1
     CLCommunic::ucLongueurTampon           1
     CLCommunic::ucCaractereRecu            1
     CLCommunic::ucEtatReception            1
     CLCommunic::cpDebutTrame               2
     CLCommunic::cpFinTrame                 2
     CLCommunic::cptrEcriture               2
     CLCommunic::cptrLecture                2
     CLCommunic::cTabCaractereRecu          2
     CLCommunic::CLCommunic()             124
     CLCommunic::CLCommunic(UC, UC, UI)
                                          160
     CLCommunic::~CLCommunic()             42
     CLCommunic::ucInitLongTrame(UC)
                                           44
     CLCommunic::ucValideTrame()           65
     CLCommunic::Send(UC)                   9
     CLCommunic::SendString(char const *)
                                           33
     CLCommunic::ucLireNbCaractRecu()
                                           14
     CLCommunic::ucLireEtatTrame()         14
     CLCommunic::ucpLireTrame()            37
     CLCommunic::vInitBaudRate(UI)         74
     CLCommunic::vInteruptSerial()        204
     CLCommunic::SendNumber(UI)           211
     CLCommunic::GetChar()                 20
     CLCommunic::ucLireEtatReception()
                                           14
     ??vInteruptSerial??INTVEC 35           3
     ?<Initializer for ucLongueurTrame>     1
     ?<Initializer for ucLongueurTampon>    1
     CLCommunic::new CLCommunic()          49
     CLCommunic::new CLCommunic(UC, UC, UI)
                                           72
     CLCommunic::delete ~CLCommunic(CLCommunic *)
                                           32

 
     3 bytes in segment INTVEC
 1 218 bytes in segment NEAR_CODE
     7 bytes in segment SFR_AN
     2 bytes in segment XDATA_I
     2 bytes in segment XDATA_ID
    14 bytes in segment XDATA_Z
 
 1 220 bytes of CODE  memory (+ 3 bytes shared)
     0 bytes of DATA  memory (+ 7 bytes shared)
    16 bytes of XDATA memory

Errors: none
Warnings: none
