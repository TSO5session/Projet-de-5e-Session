###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.1.40194/W32 for 8051         30/Sep/2014  20:43:27 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  near                                               #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Synchro\Dropbox\Travaux\Automne                 #
#                          2014\Fonctions\Projet Accumulatif                  #
#                          IAR\CLCommunicUpsdPort1.cpp                        #
#    Command line       =  "C:\Synchro\Dropbox\Travaux\Automne                #
#                          2014\Fonctions\Projet Accumulatif                  #
#                          IAR\CLCommunicUpsdPort1.cpp" -D DALLAS89C450       #
#                          --preprocess=cl "C:\Synchro\Dropbox\Travaux\Automn #
#                          e 2014\Fonctions\Projet Accumulatif                #
#                          IAR\DALLAS\List\" -lC "C:\Synchro\Dropbox\Travaux\ #
#                          Automne 2014\Fonctions\Projet Accumulatif          #
#                          IAR\DALLAS\List\" -lA "C:\Synchro\Dropbox\Travaux\ #
#                          Automne 2014\Fonctions\Projet Accumulatif          #
#                          IAR\DALLAS\List\" -o "C:\Synchro\Dropbox\Travaux\A #
#                          utomne 2014\Fonctions\Projet Accumulatif           #
#                          IAR\DALLAS\Obj\" -e --no_cse --no_unroll           #
#                          --no_inline --no_code_motion --no_tbaa --debug     #
#                          --core=plain --dptr=16,1 --data_model=large        #
#                          --code_model=near --calling_convention=xdata_reent #
#                          rant --place_constants=data --nr_virtual_regs 8    #
#                          --dlib_config "C:\Program Files (x86)\IAR          #
#                          Systems\Embedded Workbench                         #
#                          6.0\8051\LIB\DLIB\dl8051Normal.h" -Ol --ec++       #
#    List file          =  C:\Synchro\Dropbox\Travaux\Automne                 #
#                          2014\Fonctions\Projet Accumulatif                  #
#                          IAR\DALLAS\List\CLCommunicUpsdPort1.lst            #
#    Object file        =  C:\Synchro\Dropbox\Travaux\Automne                 #
#                          2014\Fonctions\Projet Accumulatif                  #
#                          IAR\DALLAS\Obj\CLCommunicUpsdPort1.r51             #
#                                                                             #
#                                                                             #
###############################################################################

C:\Synchro\Dropbox\Travaux\Automne 2014\Fonctions\Projet Accumulatif IAR\CLCommunicUpsdPort1.cpp
      1          //**********************  Fichier: CLCommunic.cpp
      2          //  Description : Fonctions necessaire pour communiquer avec le port serie:
      3          //
      4          // 
      5          //CLCommunic()                                          Constructeur par defaut
      6          //CLCommunic(UC ucLongBuf, UC ucLongTrame, UI uiBaud)  Construct initialisateur
      7          //~CLCommunic()                                                     Destructeur 
      8          //UC ucInitLongTrame(UC ucLong)                 Pour initialiser longueur trame
      9          //UC static ucLireNbCaractRecu()         Fct pour lire nombre de caractere recu
     10          //UC ucLireEtatTrame()                         Fct pour lire l'etat de la trame
     11          //char *ucpLireTrame()                Fct qui retourne adresse du debut lecture
     12          //vTransCaratere(UC ucCar)                    Fct pour transmettre un caractere
     13          //vTransChiffre(UI uiChiffreAAfficher)          Fct pour transmettre un chiffre 
     14          //vAffChaine(char const *ucpMessage)   Fct pour transmettre chaine de caractere
     15          //void vInitBaudRate(UI uiBaud)        Fct pour intialiser le baudrate et timer
     16          //__interrupt static void vInteruptSerial();     Fct pour recevoir un caractere
     17          //UC ucValideTrame()                                 Fct pour valider une trame
     18          //
     19          //  Composition: aucune
     20          //  Heritage : aucun
     21          //
     22          //  Programmeur: Philippe Dubois
     23          //  Cours: 247-436
     24          //                                                                           
     25          //  Date: 10 avril 2014
     26          //                                                                           //
     27          //  Compilateur: IAR 8.1                                  
     28          //                                                                           //
     29          //  Modification:                                                            //
     30          //                                                                           //
     31          ///////////////////////////////////////////////////////////////////////////////
     32          #include "CLCommunicUpsdPort1.h"             //inclue CLCommunic.h.
     33          #include "ConversionKeilToIAR.h"
     34          
     35           ///// Initialise les variables statiques.
     36          UC    CLCommunic :: ucEtatTrame       = INCOMPLET;      // Trame incomplete.
     37          UC    CLCommunic :: ucNbCaractRecu    = 0;              // Nombre de caractere recu = 0
     38          UC    CLCommunic :: ucLongueurTrame   = LONGUEURTRAME;  // Initialise les longueur du 
     39          UC    CLCommunic :: ucLongueurTampon  = LONGUEURTAMPON; // buffer et trame.
     40          UC    CLCommunic :: ucCaractereRecu   = NULL;
     41          UC    CLCommunic :: ucEtatReception   = INACTIF;
     42          char *CLCommunic :: cpDebutTrame      = NULL;           // Initialise lse pointeur a NULL.
     43          char *CLCommunic :: cpFinTrame        = NULL;
     44          char *CLCommunic :: cptrEcriture      = NULL;
     45          char *CLCommunic :: cptrLecture       = NULL;
     46          char *CLCommunic :: cTabCaractereRecu = NULL;
     47          
     48          
     49          //*****************************************************************************
     50          // Nom de la fct:   CLCommunic(void)
     51          // Description:     Constructeur qui permet d'initialiser par defaut le port  
     52          //                  serie du micro controleur a  9600 bdr, un tampon de 12
     53          //                  et une trame a 4 characteres. Initialise les differents
     54          //                  pointeurs au debut et la la fin du tampon.
     55          //
     56          // INCLUDE:         #include "_TypeCible.h", "CLCommunic.h" 
     57          // Prototype:       CLCommunic(void);
     58          //
     59          //
     60          // Parametre d'entree: Aucune
     61          //                     
     62          // Parametre de sortie: Aucune
     63          //
     64          // Procedure appelees: vInitBaudRate(), 
     65          //                     
     66          // Exemple d'appel: class CLCommunic clCommunic();
     67          //
     68          // Fait par: Philippe Dubois
     69          // Date:            10 avril 2014       
     70          // Revision :       A      
     71          // Modification : 
     72          //***************************************************************************** 
     73          CLCommunic::CLCommunic(void)
     74          {
     75           cTabCaractereRecu = new char[LONGUEURTAMPON]; // Definit tableau de longueur
     76                                                         // LONGUEURTAMPON.
     77           ucLongueurTrame  = LONGUEURTRAME;             // Definit longueur de la trame.
     78           ucLongueurTampon = LONGUEURTAMPON;            // Definit longueur tampon.
     79           
     80           cpDebutTrame = &cTabCaractereRecu[0];                  // Pointeur sur debut tampon.
     81           cpFinTrame   = &cTabCaractereRecu[(LONGUEURTAMPON-1)]; // Pointeur sur fin tampon
     82           cptrEcriture = &cTabCaractereRecu[0];                  // Pointeur ecriture au debut.
     83           cptrLecture  = &cTabCaractereRecu[0];                  // Pointeur lecture au debut.
     84           
     85           vInitBaudRate(9600);                                   // Initialise le port serie.
     86          }
     87          
     88          
     89          //*****************************************************************************
     90          // Nom de la fct:   CLCommunic
     91          // Description:     Constructeur qui permet d'initialiser  le port  
     92          //                  serie du micro controleur a  la vitesse voulue, un tampon 
     93          //                  de taille dynamique et la longueur de la trame.
     94          //                  Initialise les differents pointeurs au debut et la la fin 
     95          //                  du tampon.
     96          //
     97          // INCLUDE:         #include "_TypeCible.h", "CLCommunic.h" 
     98          // Prototype:     CLCommunic(UC ucLongBuf, UC ucLongTrame, UI uiBaud);  
     99          //
    100          //
    101          // Parametre d'entree: ucLongBuf pour longueur du trableau
    102          //                     ucLongTrame pour longueur trame
    103          //                     uiBaud pour la vitesse du port serie
    104          //
    105          // Parametre de sortie: Aucune
    106          //
    107          // Procedure appelees: vInitBaudRate(), ucInitLongTrame()
    108          //                     
    109          // Exemple d'appel: class CLCommunic clCommunic();
    110          //
    111          // Fait par: Philippe Dubois
    112          // Date:            10 avril 2014       
    113          // Revision :       A      
    114          // Modification : 
    115          //*****************************************************************************
    116          CLCommunic :: CLCommunic(UC ucLongBuf, UC ucLongTrame, UI uiBaud)
    117          {
    118           cTabCaractereRecu = new char[ucLongBuf]; // Initialise un tableau de longueur
    119                                                    // voulue.
    120           ucLongueurTampon = ucLongBuf;            // Longueur tampon = ucLongBuf.
    121           ucInitLongTrame(ucLongTrame);            // Verifie si longueur trame 
    122                                                    // < longueur tampon. 
    123           cpDebutTrame = &cTabCaractereRecu[0];    // Pointeur pour debut tampon.
    124           cpFinTrame   = &cTabCaractereRecu[(ucLongBuf-1)];// Pointeur pour fin tampon.
    125           cptrEcriture = &cTabCaractereRecu[0];    // Pointeur ecriture et lecture au 
    126           cptrLecture  = &cTabCaractereRecu[0];    // debut du tampon.
    127           vInitBaudRate(uiBaud);                   // Initialise la vitesse de 
    128                                                    // communication.
    129          }
    130          
    131          //*****************************************************************************
    132          // Nom de la fct:   ~CLCommunic
    133          // Description:     Desctructeur qui libert la memoire pris par le tampon. 
    134          //
    135          // INCLUDE:        #include "_TypeCible.h", "CLCommunic.h" 
    136          // Prototype:      ~CLCommunic(void); 
    137          //
    138          //
    139          // Parametre d'entree: aucun
    140          //
    141          // Parametre de sortie: Aucun
    142          //
    143          // Procedure appelees: aucun
    144          //                     
    145          // Exemple d'appel:  
    146          //
    147          // Fait par: Philippe Dubois
    148          // Date:            10 avril 2014       
    149          // Revision :       A      
    150          // Modification : 
    151          //*****************************************************************************
    152          CLCommunic :: ~CLCommunic(void)
    153          {
    154          if(cTabCaractereRecu)            // Verification pour s'assurer que le 
    155            {                                // pointeur n'a pas deja ete libere
    156             delete cTabCaractereRecu;       // Libert la memoire prise par le tampon.
    157             cTabCaractereRecu = NULL;       // Pour mettre a 0 le pointeur.
    158            }
    159          }
    160          
    161          //*****************************************************************************
    162          // Nom de la fct:   ucInitLongTrame
    163          // Description:     Verifie si la trame entree est inferieure au tampon
    164          //                  sinon la longueur de la trame = a celle du buffer.
    165          //
    166          // INCLUDE:        #include "_TypeCible.h", "CLCommunic.h" 
    167          // Prototype:      UC ucInitLongTrame(UC ucLong);
    168          //
    169          //
    170          // Parametre d'entree: ucLong longueur voulue
    171          //
    172          // Parametre de sortie: ucValide pour valide ou non la taille
    173          //
    174          // Procedure appelees: aucun
    175          //                     
    176          // Exemple d'appel:  ucInitLongTrame(ucLongTrame);
    177          //
    178          // Fait par: Philippe Dubois
    179          // Date:            10 avril 2014       
    180          // Revision :       A      
    181          // Modification : 
    182          //*****************************************************************************
    183          
    184          UC CLCommunic :: ucInitLongTrame(UC ucLong)
    185          {
    186          UC ucValide;                           // Varaible pour valider ou non.
    187          
    188          if(ucLong <= ucLongueurTampon)         // Si longueur trame voulue <= a la longueur
    189            {                                    // du tampon.
    190             ucLongueurTrame = ucLong;           // longueur trame = longueur trame voulue.
    191             ucValide = VRAI;                    // ucValide = Vrai.
    192            }
    193          
    194          if(ucLong > ucLongueurTampon)          // Si longueur trame voulue > a la longueur
    195            {                                    // du tampon.
    196             ucLongueurTrame = ucLongueurTampon; // longueur trame = longueur tampon.
    197             ucValide = FAUX;                    // ucValide = Faux.
    198            } 
    199          
    200          return(ucValide);                      // Retourne etat de ucValide.
    201          }
    202          
    203          
    204          //*****************************************************************************
    205          // Nom de la fct:   ucValideTrame
    206          // Description:     Valide la trame recue, additionne tous les caracteres 
    207          //                  recues et commpare avec le checksum.
    208          //
    209          // INCLUDE:        #include "_TypeCible.h", "CLCommunic.h" 
    210          // Prototype:      UC ucValideTrame(void);
    211          //
    212          //
    213          // Parametre d'entre: aucun
    214          //
    215          // Parametre de sortie: ucValide pour valide ou non la trame.
    216          //
    217          // Procedure appelees: aucun
    218          //                     
    219          // Exemple d'appel: if(ucValideTrame() == VRAI)
    220          //
    221          // Fait par: Philippe Dubois
    222          // Date:            10 avril 2014       
    223          // Revision :       A      
    224          // Modification : 
    225          //*****************************************************************************
    226          UC CLCommunic :: ucValideTrame(void)
    227          {
    228          UC ucValide;               // Variable pour etat valide ou non.      
    229          UC ucSomme;                // variable pour la somme des caracteres recus.
    230          ucSomme = 0;               // Initialise la somme a 0.
    231          UC ucBoucle;               // Varialbe pour boucle.
    232           
    233          char *cPtrVerification;    // pointeur sur la tramme recu
    234          cPtrVerification = cptrLecture; // Intialise l'adresse du debut de la trame.
    235            
    236          ucBoucle = (ucLongueurTrame - 1);         // Pour additionner toutes les valeurs
    237                                                    // sauf le dernier
    238          for(;ucBoucle > 0; ucBoucle--)
    239            {
    240             ucSomme = *cPtrVerification + ucSomme; // Additionne le caractere avec somme.
    241             cPtrVerification ++;                   // Valeur suivante.        
    242            }
    243                                                    // Compare la somme avec le checksum recu.
    244          if(ucSomme == *cPtrVerification)          // Si egal?
    245            {
    246             ucValide = VRAI;                       // Trame correcte.
    247            }
    248          else                                      // Sinon 
    249            {
    250             ucValide = FAUX;                       // Trame incorrecte.
    251            }
    252          
    253          return(ucValide);                         // Retourne valide ou non.
    254          } 
    255          
    256          //*****************************************************************************
    257          // Nom de la fct:   vTransCaratere                  Fait par: Philippe Dubois
    258          // Date:            2 octobre 2013             
    259          // Revision :       A      
    260          // Modification : 
    261          // INCLUDE:         #include "_TypeCible.h", "CLCommunic.h" 
    262          // Prototype:       void vTransCaratere(UC ucCar);
    263          //
    264          // Description:     Fonction qui permet de transmettre un caractere par le port 
    265          //                  serie, et on attend que le caractere soit completement 
    266          //                  envoye par "polling" avec le flag TI_0.
    267          //
    268          // Parametre d'entree: ucCar: caractere qu'on veut envoyer. 
    269          //                     
    270          //
    271          // Parametre de sortie: aucune
    272          //
    273          // Procedure appelees: aucune.
    274          //                     
    275          // Exemple d'appel: clCommunic.vTransCaratere('A') 
    276          //*****************************************************************************
    277          void CLCommunic :: vTransCaratere(UC ucCar)
    278          {
    279          SBUF0 = ucCar;             // Envoye le caractere dans SBUF0 pour le transmetre sur TX                     
    280          while(TI_0 ==0);           // Si le flag TI_0 se met a 1 (termine)
    281          TI_0  = 0;                 // Remet le flag a 0.
    282          }
    283          
    284          
    285          
    286          //*****************************************************************************
    287          // Nom de la fct:   vAffChaine
    288          // Description:     Transmet une chaine de caracteres sur le port serie.
    289          //
    290          // INCLUDE:        #include "_TypeCible.h", "CLCommunic.h" 
    291          // Prototype:      void vAffChaine(char const *ucpMessage)
    292          //
    293          //
    294          // Parametre d'entre: *ucpMessage pour chaine de caractere.
    295          //
    296          // Parametre de sortie: aucun
    297          //
    298          // Procedure appelees: vTransCaratere()
    299          //                     
    300          // Exemple d'appel: clCommunic.vAffChaine("TEST");
    301          //
    302          // Fait par: Philippe Dubois
    303          // Date:            10 avril 2014       
    304          // Revision :       A      
    305          // Modification : 
    306          //*****************************************************************************
    307          void CLCommunic :: vAffChaine(char const *ucpMessage)
    308          {
    309          while(*ucpMessage != 0x00)          // Tant qu'on a pas atteint la fin de 
    310            {                                 // la chaine.
    311             vTransCaratere(*ucpMessage);     // Transmet le caractere.
    312             ucpMessage++;                    // Passe au caractere suivant.
    313            }
    314          }
    315          
    316          //*****************************************************************************
    317          // Nom de la fct:   ucLireNbCaractRecu                Fait par: Philippe Dubois
    318          // Date:            2 octobre 2013             
    319          // Revision :       A      
    320          // Modification : 
    321          // INCLUDE:         #include "_TypeCible.h", "CLCommunic.h" 
    322          // Prototype:       UC ucLireNbCaractRecu(void);
    323          //
    324          // Description:     Fonction qui retourne le nombre de caractere recu. 
    325          //                  
    326          //
    327          // Parametre d'entree: aucun 
    328          //                     
    329          //
    330          // Parametre de sortie: ucNombreCaractere: nombre de caractere recu.
    331          //
    332          // Procedure appelees: aucune.
    333          //                     
    334          // Exemple d'appel: if(ucLireNbCaractRecu() < (ucLongueurTrame -1))
    335          //*****************************************************************************
    336          UC CLCommunic :: ucLireNbCaractRecu(void)
    337          {
    338          return(ucNbCaractRecu);          // Retourne le nombre de caractere recu.
    339          }
    340          //*****************************************************************************
    341          // Nom de la fct:   ucLireEtatTrame                  Fait par: Philippe Dubois
    342          // Date:            2 octobre 2013             
    343          // Revision :       A      
    344          // Modification : 
    345          // INCLUDE:        #include "_TypeCible.h", "CLCommunic.h" 
    346          // Prototype:       UC ucLireEtatTrame(void);
    347          //
    348          // Description:     Fonction qui permet de savoir si une trame est complete. 
    349          //                  
    350          //
    351          // Parametre d'entree: aucun 
    352          //                     
    353          //
    354          // Parametre de sortie: ucEtatTrameRecu: a 1 pour complete et 0 si imcomplete.
    355          //
    356          // Procedure appelees: aucune.
    357          //                     
    358          // Exemple d'appel:if(ucLireEtatTrame()==TRAMECOMPLET) 
    359          //*****************************************************************************
    360          UC CLCommunic :: ucLireEtatTrame(void)
    361          {
    362          return(ucEtatTrame);            // Retourne l'etat de la trame.
    363          }
    364          //*****************************************************************************
    365          // Nom de la fct:   *ucpLireTrame                   Fait par: Philippe Dubois
    366          // Date:            2 octobre 2013             
    367          // Revision :       A      
    368          // Modification : 
    369          // INCLUDE:         #include "_TypeCible.h", "CLCommunic.h" 
    370          // Prototype:       UI *ucpLireTrame(void);
    371          //
    372          // Description:     Fonction qui permet de transmettre l'adresse du tableau 
    373          //                  contenant la trame de caractere, et reinitialiser l'etat  
    374          //                  de la  trame.
    375          //
    376          // Parametre d'entree: aucun 
    377          //                     
    378          //
    379          // Parametre de sortie: uiTab: adresse du tableau.
    380          //
    381          // Procedure appelees: ucValideTrame()
    382          //                     
    383          // Exemple d'appel:vTransCaratere('A') 
    384          //*****************************************************************************
    385          char *CLCommunic :: ucpLireTrame(void)
    386          {
    387          char *ucptrLectAEnvoyer;           // Pointeur sur la trame recue.
    388          ucEtatTrame = INCOMPLET;           // Reinitialise l'etat de la trame.
    389          
    390          if(ucValideTrame() == VRAI)        // Verifie si la trame est valide.
    391            {                                // Si elle l'est 
    392             ucptrLectAEnvoyer = cptrLecture;// transmet l'adresse du debut de la trame.
    393            }
    394          else                               // Sinon
    395            {
    396             ucptrLectAEnvoyer = NULL;       // Ne transmet pas l'adresse du debut de 
    397            }                                // la trame.
    398          return(ucptrLectAEnvoyer);         // Retourne l'adresse du tableau ou NULL. 
    399          }
    400          //*****************************************************************************
    401          // Nom de la fct:   vInitBaudRate                  Fait par: Philippe Dubois
    402          // Date:            2 octobre 2013         version base
    403          //                  10 avril 2014          version avec uPSD.
    404          // Revision :       B      
    405          // Modification : 
    406          // INCLUDE:         #include "_TypeCible.h", "CLCommunic.h" 
    407          // Prototype:       void vInitBaudRate(UI uiBaud);
    408          //
    409          // Description:     Fonction qui permet d' initialiser le port série au 
    410          //                  baudrate desire, le timer 1(8 bit auto reload) et  
    411          //                  les interuptions necessaire pour communiquer avec 
    412          //                  le port serie.
    413          //                  Ajout de la compilation conditionnelle pour choix
    414          //                  de la valeur a mettre dans TH1 selon la cible.
    415          //
    416          // Parametre d'entree: UI uiBaud: pour determine la vitesse du baudrate. 
    417          //                     
    418          //
    419          // Parametre de sortie: aucune
    420          //
    421          // Procedure appelees: aucune.
    422          //                     
    423          // Exemple d'appel: vInitBaudRate(57600);
    424          //*****************************************************************************
    425          void CLCommunic:: vInitBaudRate(UI uiBaud)
    426          {
    427          SCON0 = 0x50;         // SM0_0=0 
    428                                // SM1_0=1
    429                                // SM2_0=0 pour longeur 10 bits et asychrone.
    430                                // REN_0=1 pour recevoir des caracteres.
    431          TMOD = TMOD | 0x20;   // M1=1
    432                                // M0=0 pour timer 8bit avec autoreload.
    433          PCON = PCON | 0x80;   // Pour doubler le baudrate (SMOD_0=1;).
    434          
    435          #ifdef DALLAS89C450   // Si la cible est le Dallas
    436          
    437          switch(uiBaud)         // switch case pour determiner la valeur en 
    438            {                    // hexa qui faut mettre a TH1 pour avoir la 
    439                             // bonne vitesse du timer pour generer
    440             case 57600:         // le baudrate.
    441                TH1= 0xFF;
    442             break;
    443             case 38400:
    444                TH1= 0xFE;
    445             break;
    446             case 19200:
    447                TH1= 0xFD;
    448             break;
    449             case 9600:
    450                TH1= 0xFA;
    451             break;
    452             case 4800:
    453                TH1= 0xF4;
    454             break;
    455             case 2400:
    456                TH1= 0xE8;
    457             break;
    458             default:
    459                TH1= 0xFA;        // Si aucune valeur ne correspond vitesse = 9600 .
    460             break; 
    461            }
    462          #endif
    463           
    464          #ifdef UPSD3254A        // Si la cible est le uPSD
    465          
    466          switch(uiBaud)         // switch case pour determiner la valeur en 
    467            {                    // hexa qui faut mettre a TH1 pour avoir la 
    468                            // bonne vitesse du timer pour generer
    469              /*case 57600:      // le baudrate.
    470              TH1= 0xFE ;
    471              break;
    472              case 38400:        // uPSD ne peut aller a ces vitesses
    473              TH1= 0xFD;
    474              break;
    475              case 19200:
    476              TH1= 0xF9;
    477              break;*/
    478              case 9600:
    479                 TH1= 0xF3;
    480              break;
    481              case 4800:
    482                 TH1= 0xE6;
    483              break;
    484              case 2400:
    485                 TH1= 0xCC;
    486              break;
    487              default:
    488                 TH1= 0xF3;         // Si aucune valeur ne correspond vitesse = 9600 .
    489              break; 
    490            }
    491          #endif 
    492           
    493          TR1  = 1;      // Active le timer 1.
    494          ET1  = 0;      // Desactive les interruptions du timer 1. 
    495          EA   = 1;      // Active les interruptions.
    496          ES   = 1;      // Active les interruptions du port serie.
                 ^
Error[Pe020]: identifier "ES" is undefined
    497          TI_0 = 0;      // Met a 0 le drapeau de la transmision serie.
    498          }
    499          
    500          //*****************************************************************************
    501          // Nom de la fct:   vInteruptSerial                  Fait par: Philippe Dubois
    502          // Date:            2 octobre 2013 
    503          //                  
    504          // Revision :       B      
    505          // Modification :   10 avril 2014     conversion pour IAR
    506          //
    507          // INCLUDE:         #include "_TypeCible.h", "CLCommunic.h" 
    508          // Prototype:       __interrupt  void CLCommunic:: vInteruptSerial(void);
    509          //
    510          // Description:     Fonction qui permet de recevoir des caracteres par le port 
    511          //                  serie, si l'interruption vient de la reception on place
    512          //                  les caracteres lus dans un tableau.
    513          //
    514          // Parametre d'entree: aucun.
    515          //                     
    516          //
    517          // Parametre de sortie: valeur dans cptrLecture pour lire les caractere recus.
    518          //
    519          // Procedure appelees: ucLireNbCaractRecu(),
    520          //                     
    521          // Exemple d'appel: aucun 
    522          //*****************************************************************************
    523          #pragma vector=0x23  // Interrupt 4 pour interruption serie au vecteur 23                                  
    524           __interrupt  void CLCommunic:: vInteruptSerial(void) 
    525          {
    526          EA = 0;                               // Desactive les interruptions.
    527          
    528          if(RI_0==1)                           // Interruption cause par la reception?
    529            {
    530             if(cptrEcriture > cpFinTrame)      // Si on a atteind la fin du buffer
    531               {
    532                cptrEcriture = cpDebutTrame;    // Retourne au debut du tampon.
    533               }      
    534               
    535            *cptrEcriture    = SBUF0;  // Lit dans SBUF0 le caractere recu et met dans le tableau.                               
    536             ucCaractereRecu = SBUF0;
    537             ucEtatReception = ACTIF;
    538             cptrEcriture++;           // Increment la position du pointeur d'ecriture.
    539              
    540             if(ucLireNbCaractRecu() < (ucLongueurTrame - 1) )
    541               {                       // Si le nombre de caractere recu est inferieur a 
    542                ucNbCaractRecu++;      // trame - 1 incremente le nombre de caracteres 
    543               }                       // recus.
    544             else                      // Si la trame est complete?
    545               {
    546                ucNbCaractRecu=0;      // Remet a 0 le compte de caractere.
    547                ucEtatTrame = COMPLET; // Indique qu'une trame est complete.
    548                cptrLecture = (cptrEcriture - (ucLongueurTrame)); 
    549                                       // Le pointeur de lecture = la position 
    550                                       // d'ecriture - la longuer de la trame.
    551               }
    552             RI_0 = 0;                 // Reinitialiser le flag de reception.
    553           }                           // Fin du if(RI_0 = 1)
    554          EA = 1;                      // Reactive les interruptions
    555          }                            // Fin de Interruption.
    556          
    557          //*****************************************************************************
    558          // Nom de la fct:   vTransChiffre
    559          // Description:     Fonction qui permet transmettre  un nombre de 0 a 
    560          //                  65000 sur le port serie.
    561          // INCLUDE:       #include "_TypeCible.h", "CLCommunic.h" 
    562          // Prototype:     void vTransChiffre(UI uiChiffreAAfficher);
    563          //
    564          //
    565          // Parametre d'entree: uiChiffreAAfficher pour chiffre a afficher
    566          //                     
    567          // Parametre de sortie: aucun
    568          //
    569          // Procedure appelees: vTransCaratere();
    570          //                     
    571          //
    572          // Exemple d'appel: vLcdAffChiffre(12345)
    573          //
    574          // Fait par: Philippe Dubois
    575          // Date:            14 novembre 2013             
    576          // Revision :       A      
    577          // Modification : 
    578          //*****************************************************************************
    579          void CLCommunic :: vTransChiffre(UI uiChiffreAAfficher)
    580          {
    581          UC ucChiffre0; // Declaration des variables
    582          UC ucChiffre1;
    583          UC ucChiffre2;
    584          UC ucChiffre3;
    585          UC ucChiffre4; // isole chaque chiffre du nombre.
    586          
    587          ucChiffre0 = ((uiChiffreAAfficher  % 10)    + 0x30);       // Unitee.  
    588          ucChiffre1 = (((uiChiffreAAfficher / 10)    % 10) + 0x30); // Dizaine
    589          ucChiffre2 = (((uiChiffreAAfficher / 100)   % 10) + 0x30); // Centaine.        
    590          ucChiffre3 = (((uiChiffreAAfficher / 1000)  % 10) + 0x30); // Millier.
    591          ucChiffre4 = ((uiChiffreAAfficher  / 10000) + 0x30);       // Dizaine de mille.
    592          
    593          if(ucChiffre4 != 0x30)                          // Si Dizaine de mille  = 0
    594            {                                           // Ne l'affiche pas 
    595             vTransCaratere(ucChiffre4);                  // Transmet les Dizaine de mille. 
    596            }
    597          
    598          if((ucChiffre4 != 0x30) || (ucChiffre3 != 0x30))// Si les 2 premiers chiffres
    599            {                                             // sont different de 0.
    600             vTransCaratere(ucChiffre3);                  // Transmet les millier.
    601            }   
    602          
    603          if((ucChiffre4 != 0x30) || (ucChiffre3 != 0x30)||(ucChiffre2 != 0x30))
    604            {                                  // Si les 3 1er chiffres sont different 
    605                                                 // de 0?    
    606             vTransCaratere(ucChiffre2);         // Transmet les centaines.
    607            }
    608          
    609          if((ucChiffre4 != 0x30)||(ucChiffre3 != 0x30)||(ucChiffre2 != 0x30)||(ucChiffre1 != 0x30)) 
    610                                            // Si les 4 premier chiffres sont 
    611            {                                    // different de 0.
    612             vTransCaratere(ucChiffre1);         // Transmet les dizianes.
    613            }        
    614           vTransCaratere(ucChiffre0);           // Transmetles unitees.
    615          }   
    616             
    617          UC CLCommunic :: ucLireTrameSansCheck(void)
    618          {
    619          ucEtatReception = INACTIF;
    620          return(ucCaractereRecu);      
    621          }
    622          
    623          UC CLCommunic :: ucLireEtatReception(void)
    624          {
    625          return(ucEtatReception);            // Retourne l'etat de la trame.
    626          }
    627          
    628          
    629          //LinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxTUX
    630          
    631          
    632          
    633          
    634          
    635          

Errors: 1
Warnings: none
