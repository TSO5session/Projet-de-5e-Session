// **************************CANBUS.cpp
// Auteur:       Vincent Chouinard
// Date:         27 octobre 2014
// Version:      1.0
// Modification: Aucune
//
// Compilateur:  IAR 8.1
//
// Description:
// *****************************************************************************
#include "_DeclarationGenerale.h" // Raccourcis de programmation & variables
#include "CANBUS.h"               // Fichier de definitions du bus CAN
#include "MCP2515.h"              // define des registres du MCP2515
#include "CLSPI.h"                // Pour utiliser le bus SPI
// *****************************************************************************
#define MCP2415                   // Pour la compilation conditionnelle
#define MCP2515_CS P1_7           // Chip Select
#define MCP2515_CHOIX_IDENTIFIANT 0x0A0
// *****************************************************************************

//******************************************************************************
//                            LE 
CONSTRUCTEUR PAR DEFAUT
// *****************************************************************************
CanBus :: CanBus(void)
{
class CLSPI SPI;  // Initialise le SPI
MCP24515_init();  // Initialise le MCP2515
ChoisirIdentifiantTX0(MCP2515_CHOIX_IDENTIFIANT); //
}

//******************************************************************************
//                            LE CONSTRUCTEUR INITIALISATEUR
// *****************************************************************************
CanBus :: CanBus(UC ucParametre) // Initialisation du CAN via MCP2515
{

}

// *****************************************************************************
//                            LE DESTRUCTEUR
// *****************************************************************************
CanBus :: ~CanBus(void)
{

}


void CanBus :: MCP24515_init(void)
{
// Envoi de la commande de  RESET , qui consiste en l'envoi de l'octet  0xC0 , par le bus SPI. 
   WriteMPC2514(1, MCP2515_RESET, 0x00, 0x00);
   Delai(1000);   // Delai permettant de s'assurer que le MCP2515 soit bien reinitialise
        
// Passage du circuit MCP2515 en  Configuration mode, necessaire 
// pour pouvoir effectuer les operations de configurations qui suivent 

   EcrireRegistreMCP2515(MCP2515_CANCTRL, 0x87);   /* Registre 0x0F.
                             - REQOP2   = 1 :
                             - REQOP1   = 0 :
                             - REQOP0   = 0 : le circuit est passé en « Configuration mode »,
                             - ABAT     = 0 : ne pas annuler toutes les transmissons en attentes, si nécéssaire,
                             - OSM          : renvois des messages, si nécessaire,
                             - CLKEN    = 1 : la broche « CLKOUT » est activée,
                             - CLKPRE1  = 1 : 
                             - CLKPRE0  = 1 : réglage du prédiviseur de l'horloge de la broche « CLKOUT » à 8,
                             - F_CLKOUT = System Clock / 8 */        
             
   EcrireRegistreMCP2515(MCP2515_TX01_INT,  0x3C); /* Registre 0x0C */
   EcrireRegistreMCP2515(MCP2515_TXRTSCTRL, 0x00); /* Registre 0x0D.
                           L'envoi d'un message - RTS - ne se fait pas sur le passage à « 0 » d'une broche,
                           mais après l'envoi de la commande « RTS », par l'intermédiaire du bus SPI */
   
/* Initialisations des registres des compteurs d'erreurs */
   EcrireRegistreMCP2515(MCP2515_TEC, 0x00); /* Registre 0x1C.
                          Mise à zéro du compteur d'erreurs en émission.*/
   EcrireRegistreMCP2515(MCP2515_REC, 0x00); /* Registre 0x1D.
                          Mise à zéro du compteur d'erreurs en réception.*/
  
/* Configurations du « Bit Timing » */                 
   EcrireRegistreMCP2515(MCP2515_CNF1, 0xC0); /* Registre 0xC0.
                            - SJW = 0 : 1 x TQ,
                            - BRP = 3. */
   EcrireRegistreMCP2515(MCP2515_CNF2, 0x9A); /* Registre 0x9A.
                            - BTLMODE = 1,
                            - SAM     = 0,
                            - PHSEG1  = 2,
                            - PRSEG   = 0. */
   EcrireRegistreMCP2515(MCP2515_CNF3, 0x07); /* Registre 0x07.
                            - SOF     = 0 : Broche « CLKOUT » activée pour la fonction de répétition de l'horloge,
                            - WAKFIL  = 0 : Wake-up filter désactivé,
                            - PHSEG : 2. */

/* Configurations des interruptions du circuit MCP2515 */
   EcrireRegistreMCP2515(MCP2515_CANINTE,  0x01); /* Registre 0x2B.
                            Autorisation des interruptions suite à la réception d'une donnée par le module « RXB0 ». */
   EcrireRegistreMCP2515(MCP2515_CANINTF,  0x00); /* Registre 0x2C.
                             Acquittement des éventuelles interruptions qui seraient en attente .*/
   EcrireRegistreMCP2515(MCP2515_EFLG,     0x00); /* Registre 0x2D */
   EcrireRegistreMCP2515(MCP2515_RXB0CTRL, 0x20); /* Registre 0x60 */
   
/* Configuration initiale du module « TXB0 » */
   EcrireRegistreMCP2515(MCP2515_TXB0CTRL, 0x03); /* Registre 0x30.
                              TXP = 0b11 : les messages ont la plus haute priorité. */
   EcrireRegistreMCP2515(MCP2515_TXB0DLC, 0x01);  /* Registre 0x35.
                             Nombre d'octets occupés par les données à envoyer : 1 octet.*/
                      
/* Configurations de l'identifiant en réception par le filtre 0 du circuit MCP2515 */    
   EcrireRegistreMCP2515(MCP2515_RXF0SIDH, 0x00);   /* Registre 0x00.
                              Identifiant initial de réception H. */
   EcrireRegistreMCP2515(MCP2515_RXF0SIDL, 0x20);   /* Registre 0x01.
                              Identifiant initial de réception L + configurations initiales du mode de fonctionnement des identifiants en réceptions. */

/* Configurations du masque de réception initial utilisé par le filtre 0 du circuit MCP2515 */
   EcrireRegistreMCP2515(MCP2515_RXM0SIDH, 0x00);   /* Registre 0x20.
                              Masque de réception initial H. */                              
   EcrireRegistreMCP2515(MCP2515_RXM0SIDL, 0x20);   /* Registre 0x21.
                              Masque de réception initial L. + configurations initiales du mode de fonctionnement des masque de réceptions. */
   
/* Configurations de l'identifiant en émission par le module « TXB0 » du circuit MCP2515 */
   EcrireRegistreMCP2515(MCP2515_TXB0SIDH, 0x00);   /* Registre 0x31.
                              Identifiant initial d'émission H. */
   EcrireRegistreMCP2515(MCP2515_TXB0SIDL, 0x00);   /* Registre 0x32.
                              Identifiant initial d'émission L + configurations initiales du mode de fonctionnement des identifiants en émissions. */
  
/* Passage du circuit MCP2515 en « Normal Operation mode » */
   EcrireRegistreMCP2515(MCP2515_CANCTRL, 0x07); /* Registre 0x0F.
                              - REQOP2 = 1,
                              - REQOP1 = 0,
                              - REQOP0 = 0 : le circuit est passé en « Normal Operation mode ». 
                              - Les réglages précédemment évoqués restent inchangés. */        
}

void CanBus :: EcrireRegistreMCP2515(UC Address, UC Data)
{
    WriteMPC2514(3, MCP2515_WRITE, Address, Data);   /* Envoi de 3 octets :
                                       - La commande d'écriture ;
                                       - L'adresse du registre dans lequel écrire ;
                                       - L'octet à écrire dans le registre. */ 
}

void CanBus :: ChoisirIdentifiantTX0(int Identifiant)
{
   unsigned char Contenu_MCP2515_TXB0SIDH = 0;
   unsigned char Contenu_MCP2515_TXB0SIDL = 0;

   // On récupère les 8 bits de poids fort de l'identifiant à configurer,
   // qui doivent être placés tels quels dans le registre « MCP2515_TXB0SIDH ». 
   Contenu_MCP2515_TXB0SIDH = (UC)(0x00FF & (Identifiant >> 3));   

// On récupère les 3 bits de poids faible de l'identifiant à configurer,
// qui doivent être placés dans le registre « MCP2515_TXB0SIDL »,
// aux bits « MCP2515_TXB0SIDL<5> », « MCP2515_TXB0SIDL<6> » et « MCP2515_TXB0SIDL<7> ».   
   Contenu_MCP2515_TXB0SIDL = (UC)(0x00E0 & (Identifiant << 5));   
   
   //Identifiant Emission H 
   EcrireRegistreMCP2515(MCP2515_TXB0SIDH, Contenu_MCP2515_TXB0SIDH);   
   // Identifiant Emission L + Configurations du mode de fonctionnement des identifiants */  
   EcrireRegistreMCP2515(MCP2515_TXB0SIDL, Contenu_MCP2515_TXB0SIDL);   
}

void CanBus :: AcquitterInterruptionsMCP2515(void)
{
   EcrireRegistreMCP2515(MCP2515_CANCTRL, 0x87);   /* Registe 0x0F.
   Le circuit est passé en « Configuration mode ». */
   EcrireRegistreMCP2515(MCP2515_CANINTF, 0x00);   /* Registre 0x2C.
   Acquittement des interruptions du circuit MCP2515. */
   EcrireRegistreMCP2515(MCP2515_CANCTRL, 0x07);   /* Registe 0x0F.
   Le circuit est passé en « Normal Operation mode ». */  
}

void CanBus :: SendMCP2515(const UC *Message)
{
UC TailleDuMessage = 0;
UC k;
UC PointeurRegistre = MCP2515_TXB0D0;

   /* Détermination du nombre d'octets de données à transmettre, et limitation à 8 octets au maximum. */
TailleDuMessage = Longueur(Message);

if(TailleDuMessage > 8)   /* Si le nombre d'octets de données à transmettre dépasse le nombre maximal d'octets possible. */
  {
   TailleDuMessage = 8;   /* Le nombre maximal d'octets possible sera tranmis par le circuit MCP2515. */
  }

EcrireRegistreMCP2515(MCP2515_TXB0DLC, TailleDuMessage);   /* Le MCP2515 est informé du nombre d'octets de données qu'il aura à tranmettre. */

   /* Chargement du message dans le MCP2515 */
for(k = 0; k < TailleDuMessage; k++)
  {
   EcrireRegistreMCP2515(PointeurRegistre, Message[k]);   /* Les registres de données du module « TXB0 »,
   dont les adresses sont consécutives, sont remplis,
   en commencant par le registre « MCP2515_TXB0D0 », d'adresse 0x36. */
   PointeurRegistre++;
   }

/* Envoi de la commande « RTS », qui consiste en l'envoi de l'octet « 0xC0 », par le bus SPI. */
WriteMPC2514(1, MCP2515_RTS_TX0, 0x00, 0x00);
Delai(10);  
}


















UC CanBus :: Longueur(const UC *Contenu)
{
UC Compteur = 0;

while(Contenu[Compteur] != '\0')
  {
   Compteur++;
  }
return(Compteur);  
}

void CanBus :: Delai(unsigned long Temps)
{
unsigned long k;
for(k = 0; k < Temps; k++);  
}

//LinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxLinuxTUX
