\documentclass[10pt,a4paper,final]{article}

\include{TeX/Packages}   % Packages et dépendances nécessaires

\include{TeX/SourceCode} % Permet de mettre du code source dans le document

\begin{document}
\renewcommand\headrulewidth{0pt}
\fancyfoot[C]{ }






\begin{center}
\includegraphics[scale=1]{Figures/School_Logo.jpg}~\\[1cm]  
\textsc{\LARGE \'{E}lectronique Programmable et Robotique}\\[1.5cm]
\Large 247-6 [1-2-3-4] 7-LI\\[0.5cm]
{ \huge \bfseries Projet de 5$\mathbf{^{e}}$ session \\[0.4cm] }
\HRule \\[1.5cm]





\begin{multicols}{2}
\begin{flushleft}



\textbf{Étudiants:}\\

\bigskip

Vincent Chouinard\\
Hicham Safoine\\
Gabriel Fortin-Bélanger\\ 
Louis-Nromand Ang-Houle\\




\end{flushleft}
\vfill
\begin{flushright}

\textbf{Professeurs:}\\
\medskip
Ali Tadli\\
Alain Champagne\\
Stéphane Deschênes\\
Étienne Tremblay\\



\end{flushright}
\end{multicols}

\bigskip
\bigskip


\includegraphics[scale=0.6]{Figures/Picture_for_Title.jpg} 

\vfill
L'usine à gaz, et le gaz, c'est de l'air!
\bigskip

{\large \today}
\end{center}






\pagebreak
\begin{spacing}{1.13999}
\tableofcontents 
\pagebreak
\listoffigures  
\listoftables 
\end{spacing}  
\pagebreak






\renewcommand\headrulewidth{1pt}
\fancyhead[L]{247-6 [1-2-3-4] 7-LI}
\fancyhead[R]{Projet de 5$\mathbf{^{e}}$ session}

\renewcommand\footrulewidth{1pt}
\fancyfoot[C]{\textbf{page \thepage}}
\fancyfoot[R]{\today}
\fancyfoot[L]{V.C., H.S., G.F-B., L-N.A-H.}
\begin{spacing}{1.5}

\section{Présentation du projet}
\begin{center}
\textbf{Interface utilisateur contrôlant une station de chargement de blocs, une station de communication, un véhicule de livraison et une station d'acquisition.}
\end{center}

Nous devons réaliser l'automatisation d'un système industriel constitué d'une station de communication, d'une station de chargement, d'un véhicule de livraison, et d'un système embarqué, le tout, contrôlé à l'aide d'une interface utilisateur réalisée sur un ordinateur de type PC. \\

\bigskip

\begin{flushleft}
\textbf{Principales composantes:}
\end{flushleft}


\begin{itemize}
\item[$\Rightarrow$] Le Bolide
\item[$\Rightarrow$] Carte Dallas DS89C450
\item[$\Rightarrow$] Carte uPSD 3254A
\item[$\Rightarrow$] SOC8200
\item[$\Rightarrow$] Table FESTO
\item[$\Rightarrow$] Carte PIC machin-chose-binouche
\item[$\Rightarrow$] Carte d'extension I{\small 2}C
\item[$\Rightarrow$] Carte d'extension SPI
\item[$\Rightarrow$] Une pile de 10.8 volts
\item[$\Rightarrow$] Quatre moteurs et autant de pneus
\end{itemize}

\subsection{Schéma bloc d'ensemble du système}

\begin{figure}[hbtp]
\caption{Vue d'ensemble du projet}
\centering
\fbox{\includegraphics[scale=0.45]{Figures/SchemaBloc/1.png}}
\end{figure}
\vfill

\include{TeX/SchemaBloc}


\subsection{Liste des logiciels}
\begin{flushleft}
\HRule
\end{flushleft}
\begin{flushleft}

\begin{multicols}{3}

\textbf{Terminaux}
\begin{itemize}
\item[•]UART Master 0.97
\item[•]Serializ3r 1.0.2
\item[•]TerraTerm
\item[•]Putty
\item[•]GTKterm 0.99.7-rc1
\item[•]Terminator
\item[•]CAPS
\item[•]tinyBootloader
\end{itemize}

\textbf{Schémas électriques}
\begin{itemize}
\item[•]OrCAD 16.2
\end{itemize}

\textbf{Gestionnaires de projet}
\begin{itemize}
\item[•]MS Project 2010
\item[•]Git Hub
\end{itemize}

\textbf{Compilateurs et IDE}
\begin{itemize}
\item[•]Visual Studio 2013
\item[•]Visual Studio 2010
\item[•]IAR 8.20
\item[•]MPLAB X version 6.00
\end{itemize}

\textbf{Éditeurs de texte}
\begin{itemize}
\item[•]Notepad++
\item[•]BowPad
\item[•]medit 1.2.0
\end{itemize}

\textbf{Systèmes d'exploitation}
\begin{itemize}
\item[•]Windows 7 SP1
\item[•]Windows 8.1
\item[•]Windows XP SP3

\item[•]Arch Linux
\end{itemize}

\textbf{Éditeurs de texte}
\begin{itemize}
\item[•]Notepad++
\item[•]BowPad
\item[•]medit 1.2.0
\end{itemize}

\textbf{Autres}
\begin{itemize}
\item[•]VMWare Workstation 10
\item[•]TeXmaker 4.3
\item[•]Xctu for Xbee
\item[•]Dukto R6
\item[•]Dia
\item[•]Microsoft Visio 2013
\item[•]Festo configuration tool
\item[•]Saleae Logic Analiser
\item[•]\LaTeX (avec plug-in Doxygen)
\end{itemize}

\end{multicols}
\end{flushleft}
\begin{flushleft}
\HRule
\end{flushleft}

Mettre des photos ici...

\pagebreak

\section{Fonctionnement matériel}

\subsection{Bloc 1}
D'un pont de vue matériel, le bloc 1 est le plus simple, car il est composé d'un ordinateur Windows muni d'une carte PCI vers CAN et d'une prise RS232 et d'une prise Ethernet. Il n'y a rien à faire, mise à part brancher les bons câbles aux bons endroits. Son rôle est de contrôler et diriger toute l'opération et de veiller au bon fonctionnement de chaque composante à l'aide d'une application en C\#. Le bloc 1 est le cerveau de l'usine.

\subsection{Bloc 2}
Le bloc 2 est composé du bolide et de la station no.1. Cette dernière, dont le cerveau est une carte uPSD, joue le rôle de centralisateur CAN. En effet, cette station reçoit des consignes\footnote{Sous forme de trames} en provenance du PC, consignes qu'elle s'empresse d'expédier aux bons endroits via Xbee. De plus, cette station reçoit des informations de la station de pesée\footnote{sous forme de trames CAN}, de la table FESTO\footnote{Via Xbee} et du bolide\footnote{Idem}. Ces informations sont systématiquement retransmises au PC via le bus CAN. Quant au bolide, il doit pouvoir fonctionner aussi bien en SPI qu'en I2C, il doit s'arrêter aux bon endroits, choisir son sens de rotation et tenir le système informé de ses moindres faits et gestes.

\subsection{Bloc 3}
Le Bloc 3 est composé de la table FESTO (incluant toutes ses pompes et ses capteurs) et d'une carte uPSD. Sur la carte uPSD est branché une carte connecteur PCF8570 que nous avons réalisé avec OrCAD, ainsi qu'une carte connecteur 5-24 volts et une carte d'extension avec convertisseurs DAC ADC. De plus, un Xbee est connecté au uPSD afin de relier ce dernier (et la table FESTO) au reste du montage. C'est cette station qui gère les opérations de la table FESTO, de la lecture des capteurs à l'activation des pompes en passant par la gestion du moteur pas à pas.

\subsection{Bloc 4}
Le bloc 4 est composé d'un système embarqué Linux basé sur le SOC8200. Son rôle principal est d'agir comme sniffeur d'informations et d'afficher sur son écran toutes les données qui transitent sur le bus CAN. Toutefois, ce dernier est en mesure de détecter une défaillance du PC, via un gestionnaire de HeartBeat, et de prendre la relève en tant que cerveau de l'opération. Le SOC8200 agit comme vice-président du bus CAN. De plus, le bloc 4 comporte une carte PIC (mettre modèle) et d'une balance (mettre modèle.) La balance pèse le poids de la cargaison et envoie l'information en RS232 à la carte PIC qui se charge de convertir la donnée au format CAN avant de l'expédier au PC.

\vfill
\pagebreak
\section{Explication des liens de communication entre les blocs}

\subsection{RS232}
Un lien RS232 de 9600 bauds est établi entre l'ordinateur et le SOC8200. Ce lien sert à l'envoi et à la réception d'un HeartBeat, afin que le SOC8200 ou l'ordinateur soit informé de toute défaillance de l'autre. Un autre lien RS232, à XYZ bauds cette foi, relie la car PIC-Machin à la balance. Ainsi, le PIC est informé de tout ce qui est pesé sur la balance.

\subsection{Xbee}
Trois Xbee sont présents sur le système, un sur le bolide, un autre sur la table FESTO (Bloc 3) et le dernier sur la carte uPSD du Bloc 2. Dès que l'un des Xbee envoie une information, les deux autres la reçoivent systématiquement.  La station du bloc 2 fait office de centralisateur en réalisant deux actions:
\begin{enumerate}
\item[1.]Transformer les données Xbee du bolide et de la table FESTO en trame CAN à destination du PC
\item[2.]Transformer les directives CAN du PC en directives Xbee intelligibles pour le bolide et la table FESTO.
\end{enumerate}

\subsection{CAN}
à écrire

\pagebreak
\section{Les trames expliquées en détail}

\subsection{RS232}
Le protocole RS232 sert à envoyer et à recevoir des HeartBeat. Le PC et le SOC 8200 s'envoient tous deux un HeartBeat par seconde, à 9600 bauds. Un HeartBeat, c'est simplement le mot "Allo". Le PC et le SOC2800 "écoutent" tous deux les HeartBeats, et si ces derniers ne leur parviennent pas, chaque dispositif tient pour acquis que l'autre est hors service et prend la relève de la gestion du bus CAN.

\subsection{CAN}
Chaque composante matérielle, du Bolide au PC, dispose d'un identifiant CAN unique allant de 000 à 005. Chaque fonctionnalité dispose d'un code d'identification suivi de deux octets de données à transmettre et de trois octets de TimeStamp. Seule exception à ce système, la pesée du bloc, qui ne dispose d'aucun octet d'identification, et c'est pourquoi nous filtrons l'ID émetteur afin de détecter l'ID matériel de la station de pesée (005). Quant à sa trame de 5 octets, elle se lit comme suit: \begin{center}
\textsc{dizaine unité point dixième centième}.
\end{center}

\begin{table}[!ht]
\caption{Index des identifiants matériel CAN}
\medskip
\centering
\begin{tabular}{|l|c|}
\hline 
\textbf{Device} & \textbf{ID matériel} \\ 
\hline 
Ordinateur & 000 \\ 
\hline 
SOC8200 & 001 \\ 
\hline 
Station 1 & 002 \\ 
\hline 
Station 2  & 003 \\ 
\hline
Véhicule & 004 \\
\hline 
Station de pesée  & 005 \\ 
\hline 
\end{tabular} 
\label{tab:testtab1}
\end{table} 

\begin{center}
Note sur les octets:\\
TS = TimeStamp; HH = heure; MM = minute; SS = seconde; [00-FF]= valeur allant de 0 à 255
\end{center}


\begin{table}[!ht]
\caption{Liste des trames CAN}
\medskip
\centering
\begin{tabular}{|l|l|l|}
\hline 
\textbf{Émetteur} & \textbf{Fonctionnalité} & \textbf{Trame CAN}  \\ 
\hline 
Ordinateur & Démarrer le véhicule & 00 00 TS TS TS 00 00  \\ 
\hline 
Ordinateur & Arrêter le véhicule & 00 01 TS TS TS 00 00  \\ 
\hline 
Véhicule & Dit: je suis arrêté & 01 00 TS TS TS 00 00  \\ 
\hline 
Véhicule & Dit: j'avance & 01 01 TS TS TS 00 00 \\ 
\hline 
Véhicule & Dit: je suis hors circuit & 01 02 TS TS TS 00 00  \\ 
\hline 
Véhicule & Dit: sa vitesse & 02 [00-FF] TS TS TS 00 00 \\ 
\hline 
Véhicule & Dit: le niveau de sa batterie & 03 [00-FF] TS TS TS 00 00 \\ 
\hline 
Table FESTO & Bloc = métal & 04 00 TS TS TS 00 00  \\ 
\hline 
Table FESTO & Bloc = orange & 04 01 TS TS TS 00 00  \\ 
\hline 
Table FESTO & Bloc = noir & 04 02 TS TS TS 00 00  \\ 
\hline 
Table FESTO & La voiture est à la table FESTO & 07 00 TS TS TS 00 00 \\ 
\hline 
Station de pesée & La voiture est à la station de pesée & 07 01 TS TS TS 00 00  \\ 
\hline 
Ordinateur & Synchronisation temporelle & 06 00 HH MM SS 00 00  \\ 
\hline 
Ordinateur & Demande le log au SOC8200 & 2B 1E TS TS TS 00 00  \\ 
\hline 
Ordinateur & Exige le sens horaire & 08 00 TS TS TS 00 00  \\ 
\hline 
Ordinateur & Exige le sens anti horaire & 08 01 TS TS TS 00 00  \\ 
\hline 
Ordinateur & Active la table FESTO & 09 00 TS TS TS 00 00  \\ 
\hline 
\end{tabular} 
\label{tab:testtab2}
\end{table} 

\pagebreak
\begin{center}
\fbox{\includegraphics[scale=0.2]{Figures/hichie.jpg}} 
\end{center}

\begin{flushleft}
\begin{large}
Bon, \textbf{Hicham}, maintenant que j'ai ton attention, j'aimerais simplement te dire ce qu'il reste à faire:\\

\bigskip

Il faut réaliser un schéma câblage de la station FESTO et du véhicule\\
Trouver toutes les datasheets et leurs URL\\
Écrire tes 3 conclusions\\
Faire le schéma bloc de la station de pesée\\
\end{large}
\end{flushleft}

\pagebreak

\section{Liste des pièces}
\begin{center}
\HRule \\
\textbf{Cartes, kits et câbles}
%\HRule
\end{center}
\begin{multicols}{3}
\begin{itemize}
\item[•]Carte Dallas
\item[•]Carte uPSD
\item[•]SOC 8200 (avec clavier et écran)
\item[•]PIC18FmachinTruc
\item[•]Carte d'extension SPI
\item[•]Carte d'extension I2C
\item[•]Carte CAN MCP2515
\item[•]Xbee
\item[•]Table FESTO
\item[•]Carte connecteur IO 24 volts
\item[•]Carte d'extension DAC ADC
\item[•]Carte Xbee vers DB9
\item[•]Câble Ethernet croisé
\item[•]Câble Ethernet régulier
\item[•]Câble DB9
\item[•]Le Bolide
\item[•]SaberTooth motor drive 2x5
\end{itemize}
\end{multicols}


\begin{center}
\HRule \\
\textbf{Composantes, pièces et puces (liste à compléter)}
\end{center}
\begin{multicols}{3}
\begin{itemize}
\item[•]PCF8574
\item[•]DAC65574
\item[•]MCP2515
\item[•]74HC07
\item[•]BS250
\item[•]MCP2515
\item[•]MCP2515
\item[•]MCP2515
\item[•]MCP2515
\item[•]MCP2515
\item[•]MCP2515
\item[•]MCP2515
\item[•]MCP2515
\item[•]MCP2515
\item[•]MCP2515
\item[•]MCP2515
\item[•]MCP2515
\end{itemize}
\end{multicols}
\begin{center}
\HRule
\end{center}



\subsection{Liens web}
\end{spacing}
\begin{flushleft}
\url{http://datasheets.maximintegrated.com/en/ds/DS89C430-DS89C450.pdf} \\
\url{http://www.datasheetcatalog.com/datasheets_pdf/U/P/S/D/UPSD3254.shtml} \\
\url{http://www.datasheetcatalog.com/datasheets_pdf/D/A/C/6/DAC6574.shtml} \\
\url{http://www.datasheetcatalog.com/datasheets_pdf/L/M/3/9/LM3914.shtml} \\
\url{http://www.datasheetcatalog.net/datasheets_pdf/P/C/F/8/PCF8574.shtml} \\
\url{http://www.datasheetcatalog.com/datasheets_pdf/O/P/T/1/OPT101.shtml} \\
\url{http://stackoverflow.com/} \\
\url{http://stackoverflow.com/} \\
\url{http://stackoverflow.com/} \\
\url{http://stackoverflow.com/} \\
\url{http://stackoverflow.com/} \\
\url{http://stackoverflow.com/} \\
\url{http://stackoverflow.com/} \\
\url{http://stackoverflow.com/} \\
\url{http://stackoverflow.com/} \\
\url{http://stackoverflow.com/} \\
\url{http://stackoverflow.com/} \\
\url{http://stackoverflow.com/} \\
\end{flushleft}
\begin{spacing}{1.5}

\include{TeX/Datasheet}

\pagebreak
\section{Schémas de toutes les cartes et circuits utilisés dans le projet}

\textbf{{\Huge Arrrg, faut-il vraiment mettre tout ça?}}

\pagebreak
\include{TeX/OrCAD}  
\include{TeX/OrCADold} 

\section{Interface PC}

\begin{figure}[hbtp]
\caption{Programme de contrôle principal}
\centering
\fbox{\includegraphics[scale=0.68]{Figures/programme.png}}
\end{figure}

Notre programme, écrit en C\# à l'aide de Visual Studio, peut se connecter au bus CAN via une carte PCI et au bus RS232 via un câble DB9 ou USB\footnote{S'il y a présence d'un FTDI}. La connexion RS232 sert à l'envoi et à la réception du HeartBeat afin d'informer le SOC8200 si l'ordinateur en venait à connaître une défaillance. De plus, des témoins lumineux s'allument en présence de données transmises et reçues. Le programme peut lire l'heure interne du PC et, par un simple clic sur le bouton « Synchroniser », inscrire son heure de référence sur la station no.1 via le bus CAN. Enfin, toutes les données pertinentes tel que l'historique, la direction, le poid du bloc, etc. sont affichées à l'écran.\\

\bigskip
 Parler de l'ordre de gestion des tâches...
\vfill
\pagebreak


\begin{figure}[hbtp]
\caption{Options CAN avancées}
\centering
\fbox{\includegraphics[scale=0.68]{Figures/2.png}}
\end{figure}
Il est possible d'utiliser des fonctionnalités CAN avancées telles que les masques et filtres de données. De plus, cette fenêtre permet de visualiser les données CAN reçues à l'état brut et non traitées, ce qui peut s'avérer utile pour du débogage.\pagebreak

\subsection{Gestion de l'historique}
\begin{figure}[hbtp]
\caption{Historique des actions}
\centering
\fbox{\includegraphics[scale=0.68]{Figures/4.png}}
\end{figure}
Toute action effectuée via le programme ainsi que toute donnée ayant transité sur le bus CAN, RS232 et TCP/IP est cataloguée en bonne et due forme dans un historique qu'il est possible de consulter et sauvegarder à tout moment.

\subsubsection{Exemple d'historique typique}
\end{spacing}
\begin{verbatim}
Insérer copié-collé de l'historique ici
\end{verbatim}
\begin{spacing}{1.5}


%\subsection{Les Ghosts Labels}
%Un ghost label est un label de texte présent sur l'interface, mais définit comme invisible. Il est donc impossible pour l'usager de le voir et d'y accéder. Leurs principales utilités est de faire office de variable globale afin de passer des paramètres entre fonctions et de déclencher des événements systèmes lorsqu'ils sont lus ou modifiés.



\pagebreak
\section{Logiciel du SOC8200}
\subsection{Description du programme}
D'un commun accord de l'équipe, le programme du SOC2800 a été écrit en script Shell. La principale raison de ce choix est Sourcery Codebench lui-même. La gestion des projets avec Sourcery est un cauchemar. Quant à la nécessité de sauvegarder pour compiler et d'utiliser une machine virtuelle, elles ne viennent qu'aggraver la situation. De plus, son gestionnaire de licence\footnote{L'un des membres de l'équipe fait dire que les licences sont une horreur inacceptable et inexcusable sur un système Linux} frustre quiconque souhaite l'utiliser. Quant au script shell, il est à la fois plus simple et permet de faire plus en moins de temps, enfin, je crois.

\subsection{Schéma bloc du script shell}
De tous les scripts, \textit{Projet.sh} est le maître, et contient l'équivalent du main. Ce fichier initialise le port série, le bus CAN, la lecture et l'envoi des heartbeat en asynchrone, ainsi que la lecture du clavier USB. Le script \textit{Projet.sh} peut aussi prendre la relève du bus CAN si le PC est dans l'incapacité d'assurer ses fonctions ou si l'utilisateur a appuyé sur la lettre A. Quant aux autres scripts, soit \textit{connexion.sh}, \textit{RxCan.sh}, \textit{tcp.sh}, \textit{can.sh} et \textit{Envoi.sh}, ce ne sont que des fonctionnalités que \textit{Projet.sh} appelle en asynchrone afin de lire et d'écrire sur le port série et sur le bus CAN.

\subsection{Gestion des processus et du temps de CPU}
Le seul processus synchrone est script principal \textit{Projet.sh}. Tous les scripts appelés par \textit{Projet.sh} ainsi que leurs processus enfants sont exécutés en asynchrone. Lorsqu'un script doit passer un paramètre à un autre script, un fichier est créé (à l'aide de la commande echo ou cat) afin de contenir le paramètre en question. Les processus impliqués se contentent de lire des fichiers.

\subsection{Format et récupération des logs}
Toutes les trames CAN reçues sont enregistrées dans le fichier «histocan» dont voici un court aperçu:
\end{spacing}

\begin{verbatim}
  can0    3  [7] 06 00 0E 0F 06 00 00
  can0    3  [7] 00 00 0E 0F 08 00 00
  can0    3  [7] 00 00 0E 0F 09 00 00
\end{verbatim}

De plus, un autre fichier (histocandate) concatène l'heure à la date dans trames reçues.
\begin{verbatim}
  ************************
  can0 3 [7] 00 00 0E 0F 09 00 00
  Wed Dec 10 14:15:07 UTC 2014
 
  ************************
  can0 3 [7] 00 00 0E 0F 0A 00 00
  Wed Dec 10 14:15:08 UTC 2014
\end{verbatim} 
\begin{spacing}{1.5}
\subsection{Liste des tests et logiciels}
Beaucoup de débogage à la chandelle avec l'écran intégré et PCANview Basic.exe.
\vfill
\pagebreak





\section{Logiciel du bolide et de la station uPSD }
Le programme de la station 1 et du bolide est écrit en C++ à l'aide d'IAR WorkBench 8.20 et la compilation conditionnelle offre de le compiler pour chacune des deux stations mentionnées. De plus, la compilation conditionnelle permet au bolide d'utiliser soit une carte d'extension I2C, soit une carte d'extension SPI pour contrôler ses moteurs et ses divers capteurs.

\subsection{Logiciel du module PIC18F258}
Le programme de la station no.1 (appelée Bloc 2 dans le cahier de consignes) est écrit en C à l'aide de MPLABX 6.00...

\subsection{Logiciel de la table FESTO}
La station no.2 (qui s'appelle Bloc no.3 dans le cahier de consignes) est composée de la table FESTO, de la carte uPSD, de la carte d'extensions IO que nous avons réalisée avec OrCAD.
\include{TeX/Heritage}

\vfill
\pagebreak

\subsection{Procédure de compilation sur IAR}
Sur IAR, vous pouvez utiliser le menu déroulant, illustré à la figure suivante, afin de compiler le code pour la carte Dallas ou pour la carte uPSD. Pour lancer une compilation, rien de plus simple que d'appuyer sur F6.

\begin{figure}[hbtp]
\caption{Choix de la cible sur IAR}
\centering
\fbox{\includegraphics[scale=1]{Figures/Procedure/procedure.png}}
\end{figure}

De plus, des paramètres de compilation optionnelle vous permettent, via la décommentation, de compiler le code pour la carte Dallas ou uPSD, pour la carte d'extension I2C ou SPI et pour un capteur de ligne à 3 ou à 5 photorécepteurs.\\
\end{spacing}
\textbf{Appercu des directives de compilation conditionnelles}
\begin{lstlisting}
   //#define UPSD3254A
   //#define DALLAS89C450
   //#define SPI_DALLAS
   //#define I2C_DALLAS
   //#define PCF_5_CAPTEURS
   //#define PCF_3_CAPTEURS
\end{lstlisting}
\begin{spacing}{1.5}

\subsection{Procédure de vérification}
Pour les vérification, rien de plus simple. Il suffit d'envoyer le fichier .hex dans le microcontrôleur et d'observer visuellement le fonctionnement du montage. Certains appellent cette technique « débogage à la chandelle\footnote{Salut Étienne !!!}. » Cela étant dit, afficher des trames et autres données sur un écran LCD aide grandement.

\vfill
\pagebreak
\section{Logiciel du module PIC18F258}
\subsection{Description du fonctionnement du programme}
La structure du programme est on ne peut plus classique, car il s'agit d'un programme écrit en C et disposant d'un bon vieux \emph{while(1)} à l'intérieur du \emph{void main(void)}. En bref, le programme initialise d'abord les différents registres du PIC, puis le bus CAN, I2C et RS232. Quant à la boucle, elle lit le poids du bloc, traduit les trames CAN en données RS232 et expédie le tout au... Où déjà?
\subsection{Procédure de compilation sur MPLAB}
C'est simple, faites ce qui est indiqué sur l'image ci-dessous:
\begin{figure}[hbtp]
\caption{Compiler avec MicroC PRO pour PIC}
\centering
\fbox{\includegraphics[scale=0.77]{Figures/Procedure/PIC.png}}
\end{figure}

\subsection{Procédure de vérification}



\include{TeX/calculs}    % calculs
\include{TeX/Conclusion} % conclusions

% ##########ICI COMMENCENT LES ANNEXES ET LE CODE SOURCE###########
\end{spacing}
\include{Codesource/cSharp}
\include{Codesource/BolideUpsd}
\include{Codesource/FESTO}
\include{Codesource/PIC}
\include{Codesource/ShellScript}
\include{TeX/joke}

\end{document}

