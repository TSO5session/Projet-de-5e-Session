\documentclass[10pt,a4paper,final]{article}

\include{TeX/Packages}   % Packages et dépendances nécessaires

\include{TeX/SourceCode} % Permet de mettre du code source dans le document

\begin{document}
\renewcommand\headrulewidth{0pt}
\fancyfoot[C]{ }






\begin{center}
\includegraphics[scale=1]{Figures/School_Logo.jpg}~\\[1cm]  
\textsc{\LARGE \'{E}lectronique Programmable et Robotique}\\[1.5cm]
\Large 247-6 [1-2-3-4] 7-LI\\[0.5cm]
{ \huge \bfseries Projet de 5$\mathbf{^{e}}$ session \\[0.4cm] }
\HRule \\[1.5cm]





\begin{multicols}{2}
\begin{flushleft}



\textbf{Étudiants:}\\

\bigskip

Vincent Chouinard\\
Hicham Safoine\\
Gabriel Fortin-Bélanger\\ 
Louis-Nomand Ang-Houle\\




\end{flushleft}
\vfill
\begin{flushright}

\textbf{Professeurs:}\\
\medskip
Ali Tadli\\
Alain Champagne\\
Stéphane Deschênes\\
Étienne Tremblay\\



\end{flushright}
\end{multicols}

\bigskip
\bigskip


\includegraphics[scale=0.6]{Figures/Picture_for_Title.jpg} 

\vfill
L'usine à gaz, et le gaz, c'est de l'air!
\bigskip

{\large \today}
\end{center}






\pagebreak
\begin{spacing}{1.13999}
\tableofcontents 
\pagebreak
\listoffigures  
\listoftables 
\end{spacing}  
\pagebreak






\renewcommand\headrulewidth{1pt}
\fancyhead[L]{247-6 [1-2-3-4] 7-LI}
\fancyhead[R]{Projet de 5$\mathbf{^{e}}$ session}

\renewcommand\footrulewidth{1pt}
\fancyfoot[C]{\textbf{page \thepage}}
\fancyfoot[R]{\today}
\fancyfoot[L]{V.C., H.S., G.F-B., L-N.A-H.}
\begin{spacing}{1.5}

\section{Présentation du projet}
Le projet de la cinquième session consiste à réaliser (mettre un cours extrait des consignes)
\begin{itemize}
\item[$\Rightarrow$] Le Bolide
\item[$\Rightarrow$] Carte Dallas DS89C450
\item[$\Rightarrow$] Carte uPSD 3254A
\item[$\Rightarrow$] SOC8200
\item[$\Rightarrow$] Table FESTO
\item[$\Rightarrow$] Carte PIC machin-chose-binouche
\item[$\Rightarrow$] Carte d'extension I{\small 2}C
\item[$\Rightarrow$] Carte d'extension SPI
\item[$\Rightarrow$] Une pile de 10.8 volts
\item[$\Rightarrow$] Quatre moteurs et autant de pneus
\end{itemize}

\subsection{Explication du projet}

\subsection{Schéma bloc d'ensemble du système}

\begin{figure}[hbtp]
\caption{Vue d'ensemble du projet}
\centering
\fbox{\includegraphics[scale=0.45]{Figures/SchemaBloc/1.png}}
\end{figure}
\vfill
\pagebreak 

\begin{figure}[hbtp]
\subsubsection{Schéma bloc du bolide}
\caption{Schéma bloc du Bolide}
\centering
\fbox{\includegraphics[scale=1.2]{Figures/SchemaBloc/bolide.png}}
\end{figure}

\vfill
\pagebreak


\begin{figure}[hbtp]
\subsubsection{Schéma bloc de la table FESTO}
\caption{Schéma bloc de la table FESTO}
\centering
\fbox{\includegraphics[scale=0.88]{Figures/SchemaBloc/festo.png}}
\end{figure}

\vfill
\pagebreak


\begin{figure}[hbtp]
\subsubsection{Schéma bloc du SOC8200}
\caption{Schéma bloc du SOC8200}
\centering
\fbox{\includegraphics[scale=1]{Figures/SchemaBloc/soc8200.png}}
\end{figure}

\vfill
\pagebreak

\subsubsection{Schéma bloc de la station de pesée}

\vfill
\pagebreak

\subsubsection{de la station no.1}

\subsection{Liste des logiciels}
\begin{flushleft}
\HRule
\end{flushleft}
\begin{flushleft}

\begin{multicols}{3}

\textbf{Terminaux}
\begin{itemize}
\item[•]UART Master 0.97
\item[•]Serializ3r 1.0.2
\item[•]TerraTerm
\item[•]Putty
\item[•]GTKterm 0.99.7-rc1
\item[•]Terminator
\item[•]CAPS
\item[•]tinyBootloader
\end{itemize}

\textbf{Gestionnaires de projet}
\begin{itemize}
\item[•]MS Project 2010
\item[•]Git Hub
\end{itemize}

\textbf{Compilateurs et IDE}
\begin{itemize}
\item[•]Visual Studio 2013
\item[•]Visual Studio 2010
\item[•]IAR 8.20
\item[•]MPLAB X version 6.00
\end{itemize}

\textbf{Éditeurs de texte}
\begin{itemize}
\item[•]Notepad++
\item[•]BowPad
\item[•]medit 1.2.0
\end{itemize}
\textbf{Schémas électriques}

\begin{itemize}
\item[•]OrCAD 16.2
\end{itemize}

\bigskip

\textbf{Systèmes d'exploitation}
\begin{itemize}
\item[•]Windows 7 SP1
\item[•]Windows 8.1
\item[•]Windows XP SP3
\item[•]CentOS
\item[•]Arch Linux
\end{itemize}

\textbf{Autres}
\begin{itemize}
\item[•]VMWare Workstation 10
\item[•]TeXmaker 4.3
\item[•]Dukto R6
\item[•]Dia
\item[•]Microsoft Visio 2013
\item[•]Festo configuration tool
\item[•]\LaTeX (avec plug-in Doxygen)
\end{itemize}

\end{multicols}
\end{flushleft}
\begin{flushleft}
\HRule
\end{flushleft}

\pagebreak
\subsection{Liste des trames}
\end{spacing}
f
\begin{spacing}{1.5}


\pagebreak

\section{Le matériel}

\subsection{Bloc 1}
D'un pont de vue matériel, le bloc 1 est le plus simple, car il est composé d'un ordinateur Windows muni d'une carte PCI vers CAN et d'une prise RS232 et d'une prise Ethernet. Il n'y a rien à faire, mise à part brancher les bons câbles aux bons endroits. Son rôle est de contrôler et diriger toute l'opération et de veiller au bon fonctionnement de chaque composante à l'aide d'une application en Csharp. Le bloc 1 est le cerveau de l'usine.

\subsection{Bloc 2}
Le bloc 2 est composé du bolide et de la station no.1. Cette dernière, dont le cerveau est une carte uPSD, joue le rôle de centralisateur CAN. En effet, cette station reçoit des consignes\footnote{Sous forme de trames} en provenance du PC, consignes qu'elle s'empresse d'expédier aux bons endroits via Xbee. De plus, cette station reçoit des informations de la station de pesée\footnote{sous forme de trames CAN}, de la table FESTO\footnote{Via Xbee} et du bolide\footnote{Idem}. Ces informations sont systématiquement retransmises au PC via le bus CAN.

\subsection{Bloc 3}
Le bloc 3 est composé d'une carte PIC (mettre modèle) et d'une balance (mettre modèle.) Comme son nom l'indique, la station de pesée pèse le bloc et envoie l'information (le poids) au PC et au SOC8200 via le bus CAN. La carte PIC fait office de convertisseur CAN vers RS232.

\subsection{Bloc 4}
Le bloc 4 est composé d'un système embarqué Linux basé sur le SOC8200. Son rôle principal est d'agir comme sniffeur d'information et d'afficher sur son écran toutes les données qui transitent sur le bus CAN. Toutefois, ce dernier est en mesure de détecter une défaillance du PC via un gestionnaire de HeartBeat et de prendre la relève en tant que cerveau de l'opération. Le SOC8200 agit comme vice-président du bus CAN.

\subsection{Explication des types de liens}

\subsubsection{RS232}
Un lien RS232 9600 Bauds est établi entre l'ordinateur et le SOC8200. Ce lien sert à l'envoi et à la réception de HeartBeat, afin que le SOC8200 ou l'ordinateur soit informé de toute défaillance de l'autre.

\subsubsection{Xbee}
Lorsque les modules Xbee sont adéquatement configurés, ils font office de remplacement au câble RS232. En effet, nos Xbee discutent entre eux à l'aide du protocole de communication RS232 à 9600 bauds.  

\subsection{Explication des trames}

\subsubsection{RS-232}
Le protocole RS-232 sert à envoyer et à recevoir des HeartBeat. Le PC et le SOC 8200 s'envoient tous deux un HeartBeat par seconde à 9600 bauds. Un HeartBeat, c'est simplement le mot "Allo". Le PC et le SOC2800 "écoutent" les HeartBeats, et si ces derniers ne sont pas entendus, chaque dispositif tient pour acquis que l'autre est hors service et prend la relève de la gestion du bus CAN.\pagebreak

\subsubsection{CAN}
Chaque composante matérielle, du Bolide au PC, dispose d'un identifiant CAN unique allant de 000 à 005. Chaque fonctionnalité dispose d'un code d'identification suivi de deux octets de données à transmettre.

\begin{table}[!ht]
\caption{Index des identifiants matériel CAN}
\medskip
\centering
\begin{tabular}{|l|c|}
\hline 
\textbf{Device} & \textbf{ID matériel} \\ 
\hline 
Ordinateur & 000 \\ 
\hline 
SOC8200 & 001 \\ 
\hline 
Station 1 & 002 \\ 
\hline 
Station 2  & 003 \\ 
\hline
Véhicule & 004 \\
\hline 
Station de pesés  & 005 \\ 
\hline 
\end{tabular} 
\label{tab:testtab1}
\end{table} 


\begin{table}[!ht]
\caption{Index des trames CAN}
\medskip
\centering
\begin{tabular}{|l|c|l|}
\hline 
\textbf{Fonctionnalité} & \textbf{Identifiant} & \textbf{Données} \\
\hline 
Démarre le véhcule & 0x00 & 0x00 \\ 
\hline 
Arrête le véhicule & 0x00 & 0x01 \\ 
\hline 
Le véhicule est arrêté & 0x01 & 0x00 \\ 
\hline 
Le véhicule est en marche& 0x01 & 0x01 \\ 
\hline 
Le véhicule est hors circuit & 0x01 & 0x02 \\ 
\hline 
Vitesse (0-100) & 0x02 & 0x00 à 0xFF \\ 
\hline 
Battrie & 0x03 & 0x00 à 0xFF \\ 
\hline 
Couleur du bloc & 0x04 & 0x00 à 0x02 \\ 
\hline 
Poids du bloc & 0x05 & 0x00 à 0xFF \\ 
\hline 
Envoyer l'heure & 0x06 & à déterminer \\ 
\hline 
No. de la station & 0x07 & 0x00 à 0x02 \\ 
\hline 
Demande de l'historique & 0xC0 & 0x00 \\ 
\hline 
Direction horaire et antihoraire & 0x08 & 0x00 à 0x01 \\
\hline
\end{tabular} 
\label{tab:testtab1}
\end{table}

\begin{table}[!ht]
\caption{Index des communications CAN}
\medskip
\centering
\begin{tabular}{|l|l|c|l|c|l|c|}
\hline 
\textbf{Émetteur} & \textbf{Action} & \textbf{ID receveur} & \textbf{Donnée envoyée} & \textbf{Récepteur} & \textbf{Erreur}\\ 
\hline 
Ordinateur & Démarrer le véhicule & 004 & 00 00  & Véhicule &  F1\\ 
\hline 
Ordinateur & Arrêter le véhicule & 004 & 00 01  & Véhicule &  F2\\ 
\hline 
Véhicule & Dit: je suis arrêté & 000 & 01 00   & Ordinateur &  F3\\
\hline 
Véhicule & Dit: j'avance & 000 & 01 01  & Ordinateur & F4\\  
\hline 
Véhicule & Dit: je suis hors circuit & 000 & 01 02  & Ordinateur &  F5\\ 
\hline 
Véhicule & Dit sa vitesse & 000 & 02 [00 à 64]  & Ordinateur &  F6\\ 
\hline 
Véhicule & Dit le niveau de sa batterie & 000 & 03 [00 à 64]  & Ordinateur &  F7\\ 
\hline 
Station 1 & Dit bloc = métal & 000 & 04 00  & Ordinateur &  F8\\ 
\hline  
Station 1 & Dit bloc = orange & 000 & 04 01  & Ordinateur &  F9\\
\hline 
Station 1 & Dit bloc = noir & 000 & 04 02  & Ordinateur &  FA\\
\hline 
Station 1 & Dit le poids du bloc & 000 & 05 [00 à 64]  & Ordinateur &  FB\\ 
\hline 
Voiture & Dit qu'elle est à la station 1 & 000 & 07 00  & Ordinateur &  FC\\ 
\hline 
Voiture & Dit qu'elle est à la station 2 & 000 & 07 01  & Ordinateur &  FD\\
\hline 
Ordinateur & Envoie l'heure & 003 & 06 à déterminer  & Station 1 &  FE\\ 
\hline 
Ordinateur & Demande le LOG & 001 & C0 00  & SOC8200 & E0\\ 
\hline
Ordinateur & Exige Horaire & 004 & 08 00  & Véhicule & E1\\ 
\hline
Ordinateur & Exige Antihoraire & 004 & 08 01  & Véhicule & E2\\ 
\hline
\end{tabular} 
\label{tab:testtab1}
\end{table}

\pagebreak
\begin{flushleft}
 Exemples de trames CAN à transmettre au PC.
 \end{flushleft} 
\end{spacing}
\begin{lstlisting}
   CAN.SendToPC("0100FF"); // Arrêté
   CAN.SendToPC("0101FF"); // En marche
   CAN.SendToPC("0102FF"); // Hors circuit
   CAN.SendToPC("02xxFF"); // Vitesse de xx
   CAN.SendToPC("03xxFF"); // Batterie chargée à xx %
   CAN.SendToPC("0400FF"); // Bloc métallique
   CAN.SendToPC("0401FF"); // Bloc noire
   CAN.SendToPC("0402FF"); // Bloc orange
   CAN.SendToPC("050064"); // Le bloc est lourd
   CAN.SendToPC("0700FF"); // Rendu à la station 1
   CAN.SendToPC("0701FF"); // Rendu à la station 2
   CAN.SendToPC("0702FF"); // Rendu à la station 3
\end{lstlisting}
\begin{spacing}{1.5}
\pagebreak

\subsubsection{XBEE}
Trois modules Xbee sont présents sur l'ensemble du projet, soit sur la station no.1 (la carte uPSD), sur la station no.2 (la table FESTO) et la station no.4, c'est-à-dire le bolide. La particularité des Xbee est que lorsqu'ils sont adéquatement configurés, tout ce qu'envoie un Xbee est reçu et lu par tous les autres Xbee à proximité, et c'est pourquoi nous avons défini un système de trames.

Note: mettre image d'un Xbee

\subsection{Liste des pièces}
\begin{center}
\HRule
\end{center}
\begin{multicols}{3}
\begin{itemize}
\item[•]Carte Dallas
\item[•]Carte uPSD
\item[•]SOC 8200 (avec clavier et écran)
\item[•]PIC18FmachinTruc
\item[•]Carte d'extension SPI
\item[•]Carte d'extension I2C
\item[•]Carte CAN MCP2515
\item[•]Xbee
\item[•]Table FESTO
\item[•]Carte connecteur IO 24 volts
\item[•]Carte d'extension DAC ADC
\item[•]Carte Xbee vers DB9
\item[•]Câble Ethernet croisé
\item[•]Câble Ethernet régulier
\item[•]Câble DB9
\item[•]Le Bolide
\item[•]SaberTooth motor drive 2x5
\item[•]
\end{itemize}
\end{multicols}
\begin{center}
\HRule
\end{center}

\include{TeX/Datasheet}

\section{Interface PC}

\begin{figure}[hbtp]
\caption{Programme de contrôle principal}
\centering
\fbox{\includegraphics[scale=0.68]{Figures/programme.png}}
\end{figure}

Notre programme, écrit en C\# à l'aide de Visual Studio, peut se connecter au bus CAN via une carte SPI\footnote{Spécifier le fabricant} et au bus RS232 via un câble DB9 ou USB\footnote{S'il y a présence d'un FTDI}. La connexion RS232 sert à l'envoi et à la réception du HeartBeat afin d'informer le SOC8200 si l'ordinateur en venait à connaître une défaillance. De plus, des témoins lumineux s'allument en présence de données transmises et reçues. Le programme peut lire l'heure interne du PC et, par un simple clic sur le bouton « Synchroniser », inscrire son heure de référence sur la station no.1 via le bus CAN.\\
\vfill
\pagebreak


\begin{figure}[hbtp]
\caption{Options CAN avancées}
\centering
\fbox{\includegraphics[scale=0.68]{Figures/2.png}}
\end{figure}
Il est possible d'utiliser des fonctionnalités CAN avancées telles que les masques et filtres de données. De plus, cette fenêtre permet de visualiser les données CAN reçues à l'état brut et non traitées, ce qui peut s'avérer utile pour du débogage.\pagebreak

\subsection{Gestion de l'historique}
\begin{figure}[hbtp]
\caption{Historique des actions}
\centering
\fbox{\includegraphics[scale=0.68]{Figures/4.png}}
\end{figure}
Toute action effectuée via le programme ainsi que toute donnée ayant transité sur le bus CAN, RS232 et TCP/IP est cataloguée en bonne et due forme dans un historique qu'il est possible de consulter et sauvegarder à tout moment.

\subsubsection{Exemple d'historique typique}
\end{spacing}
\begin{verbatim}
Insérer copié-collé de l'historique ici
\end{verbatim}
\begin{spacing}{1.5}

\subsection{Structure du programme}

\subsubsection{Les Ghosts Labels}
Un ghost label est un label de texte présent sur l'interface, mais définit comme invisible. Il est donc impossible pour l'usager de le voir et d'y accéder. Leurs principales utilités est de faire office de variable globale afin de passer des paramètres entre fonctions et de déclencher des événements systèmes lorsqu'ils sont lus ou modifiés.
\subsection{Explication des trames}

\subsection{Ordre de gestion des tâches}





\pagebreak
\section{Logiciel du SOC8200}
\subsection{Description du programme}
D'un commun accord de l'équipe, le programme du SOC2800 est écrit en script Shell. La principale raison de ce choix est Sourcery Codebench lui-même. La gestion des projets avec Sourcery est un cauchemar. Quant à la nécessité de sauvegarder pour compiler et d'utiliser une machine virtuelle, elles ne viennent qu'aggraver la situation. De plus, son gestionnaire de licence\footnote{L'un des membres de l'équipe fait dire que les licences sont une horreur inacceptable et inexcusable sur un système Linux} frustre quiconque souhaite l'utiliser. L'utilisation du script shell est à la fois plus simple et permet de faire plus en moins de temps.

\subsection{Schéma bloc du script shell}
De tous les scripts, \textit{Projet.sh} est le maître, et contient l'équivalent du main. Ce fichier initialise le port série, le bus CAN, la lecture et l'envoi des heartbeat en asynchrone, ainsi que la lecture du clavier USB. Le script \textit{Projet.sh} peut aussi prendre la relève du bus CAN si le PC est dans l'incapacité d'assurer ses fonctions. Quant aux autres scripts, soit \textit{connexion.sh}, \textit{RxCan.sh}, \textit{tcp.sh} et \textit{Envoi.sh}, ce ne sont que des fonctionnalités que \textit{Projet.sh} appelle en asynchrone.

\subsection{Gestion des processus et du temps de CPU}
Le seul processus synchrone est script principal \textit{Projet.sh}. Tous les scripts appelés par \textit{Projet.sh} ainsi que leurs processus enfants sont exécutés en asynchrone. Lorsqu'un script doit passer un paramètre à un autre script, un fichier est créé (à l'aide de la commande echo ou cat) afin de contenir le paramètre en question. Les processus impliqués se contentent de lire des fichiers.

\subsection{Format et récupération des logs}
Toutes les trames CAN reçues sont enregistrées dans le fichier «histocan» dont voici un court aperçu:
\end{spacing}

\begin{verbatim}
  can0    3  [7] 06 00 0E 0F 06 00 00
  can0    3  [7] 00 00 0E 0F 08 00 00
  can0    3  [7] 00 00 0E 0F 09 00 00
  can0    3  [7] 00 00 0E 0F 0A 00 00
  can0    3  [7] 00 01 0E 0F 0B 00 00
  can0    3  [7] 2B 1E 0E 0F 0E 00 00
  can0    3  [7] 00 00 0E 0F 1C 00 00
  can0    3  [7] 00 01 0E 0F 1C 00 00
\end{verbatim}

De plus, un autre fichier (histocandate) contient l'heure et la date des trames reçues.
\begin{verbatim}
  ************************
  can0 3 [7] 00 00 0E 0F 09 00 00
  Wed Dec 10 14:15:07 UTC 2014
 
  ************************
  can0 3 [7] 00 00 0E 0F 0A 00 00
  Wed Dec 10 14:15:08 UTC 2014
 
  ************************
  can0 3 [7] 00 01 0E 0F 0B 00 00
  Wed Dec 10 14:15:09 UTC 2014
\end{verbatim} 
\begin{spacing}{1.5}
\vfill
\pagebreak
\subsection{Liste des tests et logiciels}






\pagebreak
\section{Logiciel de la station 1 et du bolide}
Le programme de la station 1 et du bolide est écrit en C++ à l'aide d'IAR WorkBench 8.20 et la compilation conditionnelle offre de le compiler pour chacune des deux stations mentionnées. De plus, la compilation conditionnelle permet au bolide d'utiliser soit une carte d'extension I2C, soit une carte d'extension SPI pour contrôler ses moteurs et ses divers capteurs.

\subsection{La station no.1}
La station no.1 est composée de uPSD et s'appelle Bloc no.2 dans le cahier de consignes. Cette station reçoit les directives du PC par le BUS CAN et les expédie sur le bus CAN (et vice-versa) aux endroits appropriés. C'est aussi à cette station qu'incombe la tâche de communiquer avec le bolide et la table FESTO via des Xbee.

\subsection{La station no.2}
La station no.2 (qui s'appelle Bloc no.3 dans le cahier de consignes) est composée de la table FESTO, de la carte uPSD, de la carte d'extensions IO que nous avons réalisées et d'un Xbee.
\pagebreak

\begin{figure}[hbtp]
\subsection{Schéma des héritages de classes}
Quelles classes utilisent quelles autres classes dans notre code?
\caption{Héritage de la classe de contrôle du véhicule}
\centering
\fbox{\includegraphics[scale=1.05]{Figures/Doxygen/clvehicule.pdf}}
\caption{Héritage de la classe de contrôle de la station no.1}
\fbox{\includegraphics[scale=0.7]{Figures/Doxygen/Station1.pdf}} 
\caption{Qui hérite du SPI?}
\fbox{\includegraphics[scale=1]{Figures/Doxygen/SPI.pdf}}
\caption{Qui hérite de l'I2C?}
\fbox{\includegraphics[scale=1]{Figures/Doxygen/i2c.pdf}}
\end{figure}

\vfill
\pagebreak

\subsection{Le bolide}
\begin{table}[!ht]
\centering
\begin{tabular}{|l|c|l|}
\hline 
\textbf{Composante} & \textbf{Adresse I{\small 2}C} & \textbf{Description} \\ 
\hline 
MAX1236 & 0x68 & Convertisseur analogique-numérique \\ 
\hline 
DS1307  & 0xD0 & Circuit d'horloge RTC \\ 
\hline 
PCF8574 & 0x40 & I/O Expender pour bus I{\small 2}C \\ 
\hline 
DAC6574 & 0x98  & Convertisseur numérique-analogique  \\ 
\hline 
OPT101  &  0x50 & Suiveur de ligne  \\ 
\hline 
\end{tabular} 
\caption{Informations sur le bus I{\small 2}C du bolide}
\label{tab:testtab1}
\end{table}

\pagebreak
\subsection{Procédure de compilation sur IAR}
Sur IAR, vous pouvez utiliser le menu déroulant, illustré à la figure suivante, afin de compiler le code pour la carte Dallas ou pour la carte uPSD. Pour lancer une compilation, rien de plus simple que d'appuyer sur F6.

\begin{figure}[hbtp]
\caption{Choix de la cible sur IAR}
\centering
\fbox{\includegraphics[scale=1]{Figures/Procedure/procedure.png}}
\end{figure}

De plus, des paramètres de compilation optionnelle vous permettent, via la décommentation, de compiler le code pour la carte Dallas ou uPSD, pour la carte d'extension I2C ou SPI et pour un capteur de ligne à 3 ou à 5 photorécepteurs.\\
\end{spacing}
\textbf{Appercu des directives de compilation conditionnelles}
\begin{lstlisting}
   //#define UPSD3254A
   //#define DALLAS89C450
   //#define SPI_DALLAS
   //#define I2C_DALLAS
   //#define PCF_5_CAPTEURS
   //#define PCF_3_CAPTEURS
\end{lstlisting}
\begin{spacing}{1.5}

\subsection{Procédure de vérification}
Pour les vérification, rien de plus simple. Il suffit d'envoyer le fichier .hex dans le microcontrôleur et d'observer visuellement le fonctionnement du montage. Certains appellent cette technique « débogage à la chandelle\footnote{Salut Étienne !!!}. » Cela étant dit, afficher des trames et autres données sur un écran LCD aide grandement.

\pagebreak
\section{Logiciel du module PIC18F258}
\subsection{Description du fonctionnement du programme}
La structure du programme est on ne peut plus classique, car il s'agit d'un programme écrit en C et disposant d'un bon vieux \emph{while(1)} à l'intérieur du \emph{void main(void)}. En bref, le programme initialise d'abord les différents registres du PIC, puis le bus CAN, I2C et RS232. Quant à la boucle, elle lit le poids du bloc, traduit les trames CAN en données RS232 et expédie le tout au... Où déjà?
\subsection{Procédure de compilation sur MPLAB}
\begin{figure}[hbtp]
\caption{Compiler avec MicroC PRO pour PIC}
\centering
\fbox{\includegraphics[scale=0.77]{Figures/Procedure/PIC.png}}
\end{figure}

\subsection{Procédure de vérification}


\include{TeX/OrCAD}      % schémas orcad
\include{TeX/calculs}    % calculs
\include{TeX/Conclusion} % conclusions

% ##########ICI COMMENCENT LES ANNEXES ET LE CODE SOURCE###########
\end{spacing}
\include{Codesource/cSharp}
\include{Codesource/BolideUpsd}
\include{Codesource/FESTO}
\include{Codesource/PIC}
\include{Codesource/ShellScript}
\include{TeX/joke}

\end{document}

