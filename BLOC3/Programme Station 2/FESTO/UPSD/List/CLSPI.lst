###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.20.2.41139 for 8051             19/Nov/2014  10:59:02 #
# Copyright 2004-2013 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  near                                               #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#                                                                             #
#    Source file        =  J:\Projet_Session5_LNAH\S2_18Nov2014\Programme     #
#                          Station 2\FESTO\Libraire\CLSPI.cpp                 #
#    Command line       =  "J:\Projet_Session5_LNAH\S2_18Nov2014\Programme    #
#                          Station 2\FESTO\Libraire\CLSPI.cpp" -D UPSD3254A   #
#                          --preprocess=cl "J:\Projet_Session5_LNAH\S2_18Nov2 #
#                          014\Programme Station 2\FESTO\UPSD\List\" -lC      #
#                          "J:\Projet_Session5_LNAH\S2_18Nov2014\Programme    #
#                          Station 2\FESTO\UPSD\List\" -lA                    #
#                          "J:\Projet_Session5_LNAH\S2_18Nov2014\Programme    #
#                          Station 2\FESTO\UPSD\List\" -o                     #
#                          "J:\Projet_Session5_LNAH\S2_18Nov2014\Programme    #
#                          Station 2\FESTO\UPSD\Obj\" -e --no_cse             #
#                          --no_unroll --no_inline --no_code_motion           #
#                          --no_tbaa --debug --core=plain --dptr=16,1         #
#                          --data_model=large --code_model=near               #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data --nr_virtual_regs 8         #
#                          --dlib_config "C:\Program Files\IAR                #
#                          Systems\Embedded Workbench                         #
#                          6.4\8051\LIB\DLIB\dl8051Normal.h" -I               #
#                          "J:\Projet_Session5_LNAH\S2_18Nov2014\Programme    #
#                          Station 2\FESTO\Libraire\" -Ol --eec++             #
#    List file          =  J:\Projet_Session5_LNAH\S2_18Nov2014\Programme     #
#                          Station 2\FESTO\UPSD\List\CLSPI.lst                #
#    Object file        =  J:\Projet_Session5_LNAH\S2_18Nov2014\Programme     #
#                          Station 2\FESTO\UPSD\Obj\CLSPI.r51                 #
#                                                                             #
#                                                                             #
###############################################################################

J:\Projet_Session5_LNAH\S2_18Nov2014\Programme Station 2\FESTO\Libraire\CLSPI.cpp
      1          // ***************** FICHIER:CLPiece.cpp
      2          //
      3          //  Description:Ce fichier contient la definition des differentes fonction 
      4          //              pour controler les pieces
      5          //
      6          //  Application realisee avec IAR
      7          //
      8          //  AUTEUR : Gabriel Fortin-Belanger
      9          //  DATE CREATION :    2014-02-07		 VERSION: 1.0
     10          //  DATE MODIFICATION: ****-**-**
     11          //
     12          //******************************************************************************
     13          
     14          #include "_DeclarationGenerale.h"

   \                                 In  segment SFR_AN, at 0x90
   \   union <unnamed> volatile __sfr _A_P1
   \                     _A_P1:
   \   000000                DS 1
     15          #include "CLSPI.h"
     16          
     17          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
     18          CLSPI :: CLSPI(void)
   \                     ??CLSPI:
     19          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     20          
     21          
     22          
     23          
     24          
     25          }
   \   000000   22           RET
     26              
     27          
     28          
     29          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
     30           CLSPI :: ~CLSPI(void)
   \                     `?~CLSPI`:
     31          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     32          
     33          
     34          
     35          
     36          }
   \   000000   22           RET
     37             
     38          
     39          

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
     40          UC CLSPI :: ucSPITransfert( UC ucMode, UC ucByte)
   \                     ??ucSPITransfert:
     41          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   E9           MOV     A,R1
   \   000001   FA           MOV     R2,A
   \   000002   EC           MOV     A,R4
   \   000003   F9           MOV     R1,A
     42          
     43            switch(ucMode)
   \   000004   EA           MOV     A,R2
   \   000005   600A         JZ      ??ucSPITransfert_1
   \   000007   14           DEC     A
   \   000008   602C         JZ      ??ucSPITransfert_2
   \   00000A   14           DEC     A
   \   00000B   604E         JZ      ??ucSPITransfert_3
   \   00000D   14           DEC     A
   \   00000E   6070         JZ      ??ucSPITransfert_4
   \   000010   22           RET
     44            {
     45              unsigned char SPI_count; 
     46            
     47              
     48              
     49                  
     50            case 0x00:
     51              for (SPI_count = 8; SPI_count > 0; SPI_count--) // single byte SPI loop
   \                     ??ucSPITransfert_1:
   \   000011   7808         MOV     R0,#0x8
   \   000013   8012         SJMP    ??ucSPITransfert_5
     52               {
     53                
     54              
     55                 if(ucByte & 0x80)
     56                 {
     57                   MOSI = 1;
     58                 }
     59                 else
     60                 {
     61                   MOSI = 0;
   \                     ??ucSPITransfert_6:
   \   000015   C295         CLR     0x90.5
     62                 }
     63                 
     64                 ucByte = ucByte << 1; // shift next bit into MSB
   \                     ??ucSPITransfert_7:
   \   000017   E9           MOV     A,R1
   \   000018   C3           CLR     C
   \   000019   33           RLC     A
   \   00001A   F9           MOV     R1,A
     65                 SCK = 0x01; // set SCK high
   \   00001B   D296         SETB    0x90.6
     66                 
     67                 
     68               
     69                 ucByte |= MISO; // capture current bit on MISO
   \   00001D   A294         MOV     C,0x90.4
   \   00001F   E4           CLR     A
   \   000020   33           RLC     A
   \   000021   C9           XCH     A,R1
   \   000022   49           ORL     A,R1
   \   000023   F9           MOV     R1,A
     70                 
     71                 
     72                 SCK = 0x00; // set SCK low
   \   000024   C296         CLR     0x90.6
   \   000026   18           DEC     R0
   \                     ??ucSPITransfert_5:
   \   000027   E8           MOV     A,R0
   \   000028   C3           CLR     C
   \   000029   9401         SUBB    A,#0x1
   \   00002B   4078         JC      ??ucSPITransfert_8
   \   00002D   E9           MOV     A,R1
   \   00002E   A2E7         MOV     C,0xE0 /* A   */.7
   \   000030   50E3         JNC     ??ucSPITransfert_6
   \   000032   D295         SETB    0x90.5
   \   000034   80E1         SJMP    ??ucSPITransfert_7
     73               }
     74              break;
     75              
     76            case 0x01:
     77           
     78              for (SPI_count = 8; SPI_count > 0; SPI_count--) // single byte SPI loop
   \                     ??ucSPITransfert_2:
   \   000036   7808         MOV     R0,#0x8
   \   000038   8010         SJMP    ??ucSPITransfert_9
     79               {
     80                  SCK = 0x01;
     81                if(ucByte & 0x80)
     82                 {
     83                   MOSI = 1;
     84                 }
     85                 else
     86                 {
     87                   MOSI = 0;
   \                     ??ucSPITransfert_10:
   \   00003A   C295         CLR     0x90.5
     88                 }   // put current outgoing bit on MOSI
     89                  ucByte = ucByte << 1; // shift next bit into MSB
   \                     ??ucSPITransfert_11:
   \   00003C   E9           MOV     A,R1
   \   00003D   C3           CLR     C
   \   00003E   33           RLC     A
   \   00003F   F9           MOV     R1,A
     90                  SCK = 0x00;            // set SCK low
   \   000040   C296         CLR     0x90.6
     91                  ucByte |= MISO;        // capture current bit on MISO
   \   000042   A294         MOV     C,0x90.4
   \   000044   E4           CLR     A
   \   000045   33           RLC     A
   \   000046   C9           XCH     A,R1
   \   000047   49           ORL     A,R1
   \   000048   F9           MOV     R1,A
   \   000049   18           DEC     R0
   \                     ??ucSPITransfert_9:
   \   00004A   E8           MOV     A,R0
   \   00004B   C3           CLR     C
   \   00004C   9401         SUBB    A,#0x1
   \   00004E   4055         JC      ??ucSPITransfert_8
   \   000050   D296         SETB    0x90.6
   \   000052   E9           MOV     A,R1
   \   000053   A2E7         MOV     C,0xE0 /* A   */.7
   \   000055   50E3         JNC     ??ucSPITransfert_10
   \   000057   D295         SETB    0x90.5
   \   000059   80E1         SJMP    ??ucSPITransfert_11
     92               }
     93            break;
     94             
     95            case 0x02:
     96             for (SPI_count = 8; SPI_count > 0; SPI_count--) // single byte SPI loop
   \                     ??ucSPITransfert_3:
   \   00005B   7808         MOV     R0,#0x8
   \   00005D   8012         SJMP    ??ucSPITransfert_12
     97              {
     98                      if(ucByte & 0x80)
     99                 {
    100                   MOSI = 1;
    101                 }
    102                 else
    103                 {
    104                   MOSI = 0;
   \                     ??ucSPITransfert_13:
   \   00005F   C295         CLR     0x90.5
    105                 } // put current outgoing bit on MOSI
    106                ucByte = ucByte << 1; // shift next bit into MSB
   \                     ??ucSPITransfert_14:
   \   000061   E9           MOV     A,R1
   \   000062   C3           CLR     C
   \   000063   33           RLC     A
   \   000064   F9           MOV     R1,A
    107               SCK = 0x00; // set SCK low
   \   000065   C296         CLR     0x90.6
    108               ucByte |= MISO; // capture current bit on MISO
   \   000067   A294         MOV     C,0x90.4
   \   000069   E4           CLR     A
   \   00006A   33           RLC     A
   \   00006B   C9           XCH     A,R1
   \   00006C   49           ORL     A,R1
   \   00006D   F9           MOV     R1,A
    109               SCK = 0x01; // set SCK high
   \   00006E   D296         SETB    0x90.6
   \   000070   18           DEC     R0
   \                     ??ucSPITransfert_12:
   \   000071   E8           MOV     A,R0
   \   000072   C3           CLR     C
   \   000073   9401         SUBB    A,#0x1
   \   000075   402E         JC      ??ucSPITransfert_8
   \   000077   E9           MOV     A,R1
   \   000078   A2E7         MOV     C,0xE0 /* A   */.7
   \   00007A   50E3         JNC     ??ucSPITransfert_13
   \   00007C   D295         SETB    0x90.5
   \   00007E   80E1         SJMP    ??ucSPITransfert_14
    110              }
    111            break;
    112              
    113            case 0x03:
    114              
    115            for (SPI_count = 8; SPI_count > 0; SPI_count--) // single byte SPI loop
   \                     ??ucSPITransfert_4:
   \   000080   7808         MOV     R0,#0x8
   \   000082   8010         SJMP    ??ucSPITransfert_15
    116             {
    117               SCK = 0x00; // set SCK low
    118                      if(ucByte & 0x80)
    119                 {
    120                   MOSI = 1;
    121                 }
    122                 else
    123                 {
    124                   MOSI = 0;
   \                     ??ucSPITransfert_16:
   \   000084   C295         CLR     0x90.5
    125                 }// put current outgoing bit on MOSI
    126               ucByte = ucByte << 1; // shift next bit into MSB
   \                     ??ucSPITransfert_17:
   \   000086   E9           MOV     A,R1
   \   000087   C3           CLR     C
   \   000088   33           RLC     A
   \   000089   F9           MOV     R1,A
    127               SCK = 0x01; // set SCK high
   \   00008A   D296         SETB    0x90.6
    128               ucByte |= MISO; // capture current bit on MISO
   \   00008C   A294         MOV     C,0x90.4
   \   00008E   E4           CLR     A
   \   00008F   33           RLC     A
   \   000090   C9           XCH     A,R1
   \   000091   49           ORL     A,R1
   \   000092   F9           MOV     R1,A
   \   000093   18           DEC     R0
   \                     ??ucSPITransfert_15:
   \   000094   E8           MOV     A,R0
   \   000095   C3           CLR     C
   \   000096   9401         SUBB    A,#0x1
   \   000098   400B         JC      ??ucSPITransfert_8
   \   00009A   C296         CLR     0x90.6
   \   00009C   E9           MOV     A,R1
   \   00009D   A2E7         MOV     C,0xE0 /* A   */.7
   \   00009F   50E3         JNC     ??ucSPITransfert_16
   \   0000A1   D295         SETB    0x90.5
   \   0000A3   80E1         SJMP    ??ucSPITransfert_17
    129             }
    130             
    131            break;
    132              
    133            
    134          
    135              
    136            }
    137          
    138            
    139            
    140            
    141             return(ucByte);
   \                     ??ucSPITransfert_8:
   \   0000A5   22           RET
   \   0000A6                REQUIRE _A_P1
    142            
    143          
    144          
    145          }

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \   __near_func __xdata_reentrant CLSPI &CLSPI::new CLSPI()
   \                     `??new CLSPI`:
   \   000000   C0..         PUSH    ?V0 + 0
   \   000002   C0..         PUSH    ?V0 + 1
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004                ; Setup parameters for call to function operator new(unsigned int)
   \   000004   7A01         MOV     R2,#0x1
   \   000006   7B00         MOV     R3,#0x0
   \   000008   12....       LCALL   `??operator new`
   \   00000B   8A..         MOV     ?V0 + 0,R2
   \   00000D   8B..         MOV     ?V0 + 1,R3
   \   00000F   A8..         MOV     R0,?V0 + 0
   \   000011   A9..         MOV     R1,?V0 + 1
   \   000013   E8           MOV     A,R0
   \   000014   FA           MOV     R2,A
   \   000015   E9           MOV     A,R1
   \   000016   FB           MOV     R3,A
   \   000017   E8           MOV     A,R0
   \   000018   49           ORL     A,R1
   \   000019   600D         JZ      `??new CLSPI_1`
   \   00001B                ; Setup parameters for call to function CLSPI::CLSPI()
   \   00001B   12....       LCALL   ??CLSPI
   \   00001E   8A..         MOV     ?V0 + 0,R2
   \   000020   8B..         MOV     ?V0 + 1,R3
   \   000022   AA..         MOV     R2,?V0 + 0
   \   000024   AB..         MOV     R3,?V0 + 1
   \   000026   8004         SJMP    `??new CLSPI_2`
   \                     `??new CLSPI_1`:
   \   000028   7A00         MOV     R2,#0x0
   \   00002A   7B00         MOV     R3,#0x0
   \                     `??new CLSPI_2`:
   \   00002C   D0..         POP     ?V0 + 1
   \   00002E   D0..         POP     ?V0 + 0
   \   000030   22           RET

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \   __near_func __xdata_reentrant void CLSPI::delete ~CLSPI(CLSPI *)
   \                     `??delete ~CLSPI`:
   \   000000   74F8         MOV     A,#-0x8
   \   000002   12....       LCALL   ?FUNC_ENTER_XDATA
   \   000005                ; Saved register size: 8
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   EE           MOV     A,R6
   \   00000A   4F           ORL     A,R7
   \   00000B   600E         JZ      `??delete ~CLSPI_1`
   \   00000D                ; Setup parameters for call to function CLSPI::~CLSPI()
   \   00000D   EE           MOV     A,R6
   \   00000E   FA           MOV     R2,A
   \   00000F   EF           MOV     A,R7
   \   000010   FB           MOV     R3,A
   \   000011   12....       LCALL   `?~CLSPI`
   \   000014                ; Setup parameters for call to function operator delete(void *)
   \   000014   EE           MOV     A,R6
   \   000015   FA           MOV     R2,A
   \   000016   EF           MOV     A,R7
   \   000017   FB           MOV     R3,A
   \   000018   12....       LCALL   `??operator delete`
   \                     `??delete ~CLSPI_1`:
   \   00001B   7F01         MOV     R7,#0x1
   \   00001D   02....       LJMP    ?FUNC_LEAVE_XDATA

   Maximum stack usage in bytes:

   ISTACK PSTACK XSTACK Function
   ------ ------ ------ --------
       0      0      0  CLSPI::CLSPI()
       0      0      8  CLSPI::delete ~CLSPI(CLSPI *)
                          0 0 8 -> CLSPI::~CLSPI()
                          0 0 8 -> operator delete(void *)
       2      0      0  CLSPI::new CLSPI()
                          2 0 0 -> CLSPI::CLSPI()
                          2 0 0 -> operator new(unsigned int)
       0      0      0  CLSPI::ucSPITransfert(UC, UC)
       0      0      8  CLSPI::~CLSPI()


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  CLSPI::CLSPI()
      32  CLSPI::delete ~CLSPI(CLSPI *)
      49  CLSPI::new CLSPI()
     166  CLSPI::ucSPITransfert(UC, UC)
       1  CLSPI::~CLSPI()
       1  _A_P1

 
 249 bytes in segment NEAR_CODE
   1 byte  in segment SFR_AN
 
 249 bytes of CODE memory
   0 bytes of DATA memory (+ 1 byte shared)

Errors: none
Warnings: none
